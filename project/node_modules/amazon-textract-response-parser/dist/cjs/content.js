"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signature = exports.SelectionElement = exports.LineGeneric = exports.WithWords = exports.buildWithContent = exports.Word = void 0;
const base_1 = require("./base");
const geometry_1 = require("./geometry");
class Word extends base_1.ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get text() {
        return this._dict.Text;
    }
    get textType() {
        return this._dict.TextType;
    }
    set textType(newVal) {
        this._dict.TextType = newVal;
    }
    html() {
        return (0, base_1.escapeHtml)(this.text);
    }
    str() {
        return this.text;
    }
}
exports.Word = Word;
function buildWithContent({ contentTypes = ["SELECTION_ELEMENT", "SIGNATURE", "WORD"], strict = false, } = {}) {
    return function WithContent(SuperClass) {
        return class extends SuperClass {
            iterContent() {
                const getIterator = () => {
                    const childBlockIds = this.childBlockIds;
                    let ixCurr = 0;
                    return {
                        next: () => {
                            let nextVal;
                            while (ixCurr < childBlockIds.length) {
                                const item = this.parentPage.getItemByBlockId(childBlockIds[ixCurr]);
                                ++ixCurr;
                                if (!contentTypes.length || contentTypes.indexOf(item.blockType) >= 0) {
                                    nextVal = item;
                                    break;
                                }
                                else if (strict) {
                                    throw new Error(`Child ${item.id} of parent ${this.id} has unexpected non-content block type ${item.blockType}`);
                                }
                            }
                            return nextVal ? { done: false, value: nextVal } : { done: true, value: undefined };
                        },
                    };
                };
                return {
                    [Symbol.iterator]: getIterator,
                };
            }
            listContent() {
                if (!this.dict.Relationships) {
                    return [];
                }
                const result = [];
                for (const cid of this.childBlockIds) {
                    const item = this.parentPage.getItemByBlockId(cid);
                    if (!contentTypes.length || contentTypes.indexOf(item.blockType) >= 0) {
                        result.push(item);
                    }
                    else if (strict) {
                        throw new Error(`Child ${item.id} of parent ${this.id} has unexpected non-content block type ${item.blockType}`);
                    }
                }
                return result;
            }
            get nContentItems() {
                return this.listContent().length;
            }
            get text() {
                return this.listContent()
                    .map((c) => c.text)
                    .join(" ");
            }
        };
    };
}
exports.buildWithContent = buildWithContent;
function WithWords(SuperClass) {
    return class extends SuperClass {
        iterWords() {
            const getIterator = () => {
                const childBlockIds = this.childBlockIds;
                let ixCurr = 0;
                return {
                    next: () => {
                        let nextVal;
                        while (ixCurr < childBlockIds.length) {
                            const item = this.parentPage.getItemByBlockId(childBlockIds[ixCurr]);
                            ++ixCurr;
                            if (item.blockType === "WORD") {
                                nextVal = item;
                                break;
                            }
                        }
                        return nextVal ? { done: false, value: nextVal } : { done: true, value: undefined };
                    },
                };
            };
            return {
                [Symbol.iterator]: getIterator,
            };
        }
        listWords() {
            if (!this.dict.Relationships) {
                console.warn(`Tried to fetch WORD children on block ${this.id} of type ${this.blockType} with no 'Relationships'`);
                return [];
            }
            const result = [];
            for (const cid of this.childBlockIds) {
                const item = this.parentPage.getItemByBlockId(cid);
                if (item.blockType === "WORD")
                    result.push(item);
            }
            return result;
        }
        get nWords() {
            return this.listWords().length;
        }
        get text() {
            return this.listWords()
                .map((c) => c.text)
                .join(" ");
        }
        wordAtIndex(ix) {
            if (ix < 0)
                throw new Error(`Word index ${ix} must be >=0`);
            let ixCurr = 0;
            for (const word of this.iterWords()) {
                if (ixCurr === ix)
                    return word;
                ++ixCurr;
            }
            throw new Error(`Word index ${ix} out of bounds for length ${ixCurr}`);
        }
    };
}
exports.WithWords = WithWords;
class LineGeneric extends WithWords(base_1.PageHostedApiBlockWrapper) {
    constructor(block, parentPage) {
        super(block, parentPage);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get text() {
        return this._dict.Text;
    }
    html() {
        return (0, base_1.escapeHtml)(this.text);
    }
    str() {
        return `Line\n==========\n${this._dict.Text}\nWords\n----------\n${this.listWords()
            .map((word) => `[${word.str()}]`)
            .join("")}`;
    }
}
exports.LineGeneric = LineGeneric;
class SelectionElement extends base_1.ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get selectionStatus() {
        return this._dict.SelectionStatus;
    }
    set selectionStatus(newVal) {
        this._dict.SelectionStatus = newVal;
    }
    html() {
        return `<input type="checkbox" disabled ${this.selectionStatus === "SELECTED" ? "checked " : ""}/>`;
    }
    str() {
        return this.selectionStatus;
    }
    get text() {
        return this.selectionStatus;
    }
}
exports.SelectionElement = SelectionElement;
class Signature extends base_1.ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    html() {
        return `<input class="signature" type="text" disabled value="[SIGNATURE]"/>`;
    }
    str() {
        return "/-------------\\\n| [SIGNATURE] |\n\\-------------/";
    }
    get text() {
        return "";
    }
}
exports.Signature = Signature;
//# sourceMappingURL=content.js.map