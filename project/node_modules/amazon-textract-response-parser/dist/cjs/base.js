"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PageHostedApiBlockWrapper = exports.argMax = exports.aggregate = exports.modalAvg = exports.AggregationMethod = exports.indent = exports.escapeHtml = exports.getIterable = exports.DocumentMetadata = exports.ApiBlockWrapper = exports.ApiObjectWrapper = void 0;
class ApiObjectWrapper {
    constructor(dict) {
        this._dict = dict;
    }
    get dict() {
        return this._dict;
    }
}
exports.ApiObjectWrapper = ApiObjectWrapper;
class ApiBlockWrapper extends ApiObjectWrapper {
    get id() {
        return this._dict.Id;
    }
    get blockType() {
        return this._dict.BlockType;
    }
    get childBlockIds() {
        return this.relatedBlockIdsByRelType("CHILD");
    }
    relatedBlockIdsByRelType(relType) {
        const isMultiType = Array.isArray(relType);
        let ids = [];
        (this._dict.Relationships || []).forEach((rs) => {
            if (isMultiType) {
                if (relType.indexOf(rs.Type) >= 0) {
                    ids = ids.concat(rs.Ids);
                }
            }
            else {
                if (rs.Type === relType) {
                    ids = ids.concat(rs.Ids);
                }
            }
        });
        return ids;
    }
}
exports.ApiBlockWrapper = ApiBlockWrapper;
class DocumentMetadata extends ApiObjectWrapper {
    get nPages() {
        var _a;
        return ((_a = this._dict) === null || _a === void 0 ? void 0 : _a.Pages) || 0;
    }
}
exports.DocumentMetadata = DocumentMetadata;
function getIterable(collectionFetcher) {
    const getIterator = () => {
        const collection = collectionFetcher();
        let ixItem = 0;
        return {
            next: () => {
                return ixItem < collection.length
                    ? {
                        done: false,
                        value: collection[ixItem++],
                    }
                    : {
                        done: true,
                        value: undefined,
                    };
            },
        };
    };
    return {
        [Symbol.iterator]: getIterator,
    };
}
exports.getIterable = getIterable;
function escapeHtml(str, { forAttr = false } = {}) {
    return str.replace(forAttr ? /[&<>'"]/g : /[&<>]/g, (entity) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;",
    })[entity]);
}
exports.escapeHtml = escapeHtml;
function indent(text, { character = "\t", count = 1, includeEmptyLines = false, skipFirstLine = false } = {}) {
    const result = text.replace(includeEmptyLines ? /^/gm : /^(?!\s*$)/gm, character.repeat(count));
    if (skipFirstLine) {
        return result.substring(count * character.length);
    }
    else {
        return result;
    }
}
exports.indent = indent;
var AggregationMethod;
(function (AggregationMethod) {
    AggregationMethod["GeometricMean"] = "GEOMEAN";
    AggregationMethod["Max"] = "MAX";
    AggregationMethod["Mean"] = "MEAN";
    AggregationMethod["Min"] = "MIN";
    AggregationMethod["Mode"] = "MODE";
})(AggregationMethod || (exports.AggregationMethod = AggregationMethod = {}));
function modalAvg(arr) {
    const freqs = {};
    for (const item of arr) {
        if (freqs[item]) {
            ++freqs[item].freq;
        }
        else {
            freqs[item] = { value: item, freq: 1 };
        }
    }
    let maxFreq = 0;
    let mode = null;
    for (const item in freqs) {
        if (freqs[item].freq > maxFreq) {
            maxFreq = freqs[item].freq;
            mode = freqs[item].value;
        }
    }
    return mode;
}
exports.modalAvg = modalAvg;
function aggregate(arr, aggMethod) {
    const actualArr = Array.isArray(arr) ? arr : Array.from(arr);
    if (actualArr.length === 0)
        return null;
    if (aggMethod === "GEOMEAN") {
        return Math.exp(actualArr.reduce((acc, next) => acc + Math.log(next), 0) / actualArr.length);
    }
    else if (aggMethod === "MAX") {
        return Math.max(...actualArr);
    }
    else if (aggMethod === "MEAN") {
        return actualArr.reduce((acc, next) => acc + next, 0) / actualArr.length;
    }
    else if (aggMethod === "MIN") {
        return Math.min(...actualArr);
    }
    else if (aggMethod === "MODE") {
        return modalAvg(actualArr);
    }
    else {
        throw new Error(`Unsupported aggMethod '${aggMethod}' not in allowed AggregationMethod enum`);
    }
}
exports.aggregate = aggregate;
function argMax(arr) {
    return arr.reduce((state, nextVal, nextIx) => (nextVal > state.maxValue ? { maxValue: nextVal, maxIndex: nextIx } : state), { maxValue: -Infinity, maxIndex: -1 });
}
exports.argMax = argMax;
class PageHostedApiBlockWrapper extends ApiBlockWrapper {
    constructor(dict, parentPage) {
        super(dict);
        this._parentPage = parentPage;
        parentPage.registerParsedItem(dict.Id, this);
    }
    get parentPage() {
        return this._parentPage;
    }
}
exports.PageHostedApiBlockWrapper = PageHostedApiBlockWrapper;
//# sourceMappingURL=base.js.map