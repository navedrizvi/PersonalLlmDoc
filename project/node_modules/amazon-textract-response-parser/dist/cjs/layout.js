"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayoutGeneric = exports.LayoutListGeneric = exports.LayoutTitleGeneric = exports.LayoutTextGeneric = exports.LayoutTableGeneric = exports.LayoutSectionHeaderGeneric = exports.LayoutPageNumberGeneric = exports.LayoutKeyValueGeneric = exports.LayoutHeaderGeneric = exports.LayoutFooterGeneric = exports.LayoutFigureGeneric = void 0;
const base_1 = require("./base");
const content_1 = require("./content");
const geometry_1 = require("./geometry");
class LayoutItemBaseGeneric extends base_1.PageHostedApiBlockWrapper {
    constructor(block, parentLayout) {
        super(block, parentLayout.parentPage);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
        this._parentLayout = parentLayout;
    }
    get confidence() {
        return this._dict.Confidence;
    }
    get geometry() {
        return this._geometry;
    }
    get parentLayout() {
        return this._parentLayout;
    }
}
class LayoutLineContainerItem extends (0, content_1.buildWithContent)({ contentTypes: ["LINE"] })(LayoutItemBaseGeneric) {
    iterTextLines() {
        return (0, base_1.getIterable)(() => this.listTextLines());
    }
    listTextLines() {
        return this.listContent();
    }
    get nTextLines() {
        return this.listTextLines().length;
    }
    get text() {
        return this.listContent()
            .map((c) => c.text)
            .join("\n");
    }
}
class LayoutFigureGeneric extends LayoutLineContainerItem {
    html() {
        const content = this.text ? `\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n` : "";
        return `<div class="figure">${content}</div>`;
    }
    str() {
        return `#### Figure ####\n${this.text}${this.text ? "\n" : ""}################`;
    }
}
exports.LayoutFigureGeneric = LayoutFigureGeneric;
class LayoutFooterGeneric extends LayoutLineContainerItem {
    html() {
        return `<div class="footer-el">\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</div>`;
    }
    str() {
        return `---- Footer text ----\n${this.text}\n---------------------`;
    }
}
exports.LayoutFooterGeneric = LayoutFooterGeneric;
class LayoutHeaderGeneric extends LayoutLineContainerItem {
    html() {
        return `<div class="header-el">\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</div>`;
    }
    str() {
        return `---- Header text ----\n${this.text}\n---------------------`;
    }
}
exports.LayoutHeaderGeneric = LayoutHeaderGeneric;
class LayoutKeyValueGeneric extends LayoutLineContainerItem {
    _listContentIdsInFormField(field) {
        const keyContentIds = field.key.listWords().map((word) => word.id);
        const fieldVal = field.value;
        return fieldVal ? keyContentIds.concat(fieldVal.listContent().map((item) => item.id)) : keyContentIds;
    }
    _mapPageContentToFormFields() {
        const contentToFields = {};
        this.parentPage.form.listFields().forEach((field) => {
            this._listContentIdsInFormField(field).forEach((id) => {
                contentToFields[id] = field;
            });
        });
        return contentToFields;
    }
    iterFields() {
        return (0, base_1.getIterable)(() => this.listFields());
    }
    listFields() {
        const wordsToFields = this._mapPageContentToFormFields();
        const consumedIds = {};
        const result = [];
        for (const line of this.iterContent()) {
            for (const word of line.iterWords()) {
                if (word.id in consumedIds)
                    continue;
                const field = wordsToFields[word.id];
                if (field) {
                    result.push(field);
                    this._listContentIdsInFormField(field).forEach((id) => {
                        consumedIds[id] = true;
                    });
                }
            }
        }
        return result;
    }
    html() {
        const wordsToFields = this._mapPageContentToFormFields();
        const consumedIds = {};
        const lineReprs = [];
        for (const line of this.iterContent()) {
            const wordReprs = [];
            for (const word of line.iterWords()) {
                const wordId = word.id;
                if (wordId in consumedIds)
                    continue;
                if (wordId in wordsToFields) {
                    const field = wordsToFields[wordId];
                    wordReprs.push(field.html());
                    this._listContentIdsInFormField(field).forEach((id) => {
                        consumedIds[id] = true;
                    });
                }
                else {
                    wordReprs.push(word.html());
                }
            }
            lineReprs.push(wordReprs.join(" "));
        }
        const innerContent = lineReprs.filter((rep) => rep).join("\n");
        return `<div class="key-value">\n${(0, base_1.indent)(innerContent)}\n</div>`;
    }
    str() {
        return `---- Key-value ----\n${this.text}\n-------------------`;
    }
}
exports.LayoutKeyValueGeneric = LayoutKeyValueGeneric;
class LayoutPageNumberGeneric extends LayoutLineContainerItem {
    html() {
        return `<div class="page-num">\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</div>`;
    }
    str() {
        return `---- Page number: ${this.text}`;
    }
}
exports.LayoutPageNumberGeneric = LayoutPageNumberGeneric;
class LayoutSectionHeaderGeneric extends LayoutLineContainerItem {
    html() {
        return `<h2>\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</h2>`;
    }
    str() {
        return `\n${this.text}\n${"-".repeat(this.text.length)}\n`;
    }
}
exports.LayoutSectionHeaderGeneric = LayoutSectionHeaderGeneric;
class LayoutTableGeneric extends LayoutLineContainerItem {
    _listContentIdsInTable(table) {
        const cellContentIds = table
            .listRows()
            .map((row) => row
            .listCells()
            .map((cell) => cell
            .listContent()
            .map((item) => item.id)
            .flat())
            .flat())
            .flat();
        const footerIds = table
            .listFooters()
            .map((foot) => foot
            .listWords()
            .map((word) => word.id)
            .flat())
            .flat();
        const titleIds = table
            .listTitles()
            .map((title) => title
            .listWords()
            .map((word) => word.id)
            .flat())
            .flat();
        return titleIds.concat(cellContentIds, footerIds);
    }
    _mapPageContentToTables() {
        const contentToTables = {};
        this.parentPage.listTables().forEach((table) => {
            this._listContentIdsInTable(table).forEach((id) => {
                contentToTables[id] = table;
            });
        });
        return contentToTables;
    }
    iterTables() {
        return (0, base_1.getIterable)(() => this.listTables());
    }
    listTables() {
        const wordsToTables = this._mapPageContentToTables();
        const consumedIds = {};
        const result = [];
        for (const line of this.iterContent()) {
            for (const word of line.iterWords()) {
                if (word.id in consumedIds)
                    continue;
                const table = wordsToTables[word.id];
                if (table) {
                    result.push(table);
                    this._listContentIdsInTable(table).forEach((id) => {
                        consumedIds[id] = true;
                    });
                }
            }
        }
        return result;
    }
    html() {
        const wordsToTables = this._mapPageContentToTables();
        const consumedIds = {};
        const lineReprs = [];
        for (const line of this.iterContent()) {
            const wordReprs = [];
            for (const word of line.iterWords()) {
                const wordId = word.id;
                if (wordId in consumedIds)
                    continue;
                if (wordId in wordsToTables) {
                    const table = wordsToTables[wordId];
                    wordReprs.push(table.html());
                    this._listContentIdsInTable(table).forEach((id) => {
                        consumedIds[id] = true;
                    });
                }
                else {
                    wordReprs.push(word.html());
                }
            }
            lineReprs.push(wordReprs.join(" "));
        }
        const innerContent = lineReprs.filter((rep) => rep).join("\n");
        return `<div class="table">\n${(0, base_1.indent)(innerContent)}\n</div>`;
    }
    str() {
        return ["|==== Table (structure unknown) ====|", this.text, "|==================================|"].join("\n");
    }
}
exports.LayoutTableGeneric = LayoutTableGeneric;
class LayoutTextGeneric extends LayoutLineContainerItem {
    html() {
        return `<p>\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</p>`;
    }
    str() {
        return this.text;
    }
}
exports.LayoutTextGeneric = LayoutTextGeneric;
class LayoutTitleGeneric extends LayoutLineContainerItem {
    html() {
        return `<h1>\n${(0, base_1.indent)((0, base_1.escapeHtml)(this.text))}\n</h1>`;
    }
    str() {
        return `\n\n${this.text}\n${"=".repeat(this.text.length)}\n`;
    }
}
exports.LayoutTitleGeneric = LayoutTitleGeneric;
class LayoutListGeneric extends (0, content_1.buildWithContent)({ contentTypes: ["LAYOUT_TEXT"] })(LayoutItemBaseGeneric) {
    html() {
        return `<ul>\n${(0, base_1.indent)(this.listContent()
            .map((item) => `<li>${item.html()}</li>`)
            .join("\n"))}\n</ul>`;
    }
    iterTextLines() {
        return (0, base_1.getIterable)(() => this.listTextLines());
    }
    listTextLines() {
        function extractLinesRecursive(items) {
            return items
                .map((item) => {
                if (item.blockType === "LINE")
                    return [item];
                else if (typeof item.listContent !== "undefined")
                    return extractLinesRecursive(item.listContent());
                else
                    return [];
            })
                .flat();
        }
        return extractLinesRecursive(this.listContent());
    }
    str() {
        return this.text;
    }
    get nTextLines() {
        return this.listTextLines().length;
    }
    get text() {
        return this.listContent()
            .map((item) => `  - ${(0, base_1.indent)(item.text, { character: " ", count: 4, skipFirstLine: true })}`)
            .join("\n");
    }
}
exports.LayoutListGeneric = LayoutListGeneric;
class LayoutGeneric {
    constructor(layoutBlocks, parentPage) {
        this._items = [];
        this._parentPage = parentPage;
        layoutBlocks.forEach((block) => {
            switch (block.BlockType) {
                case "LAYOUT_FIGURE":
                    this._items.push(new LayoutFigureGeneric(block, this));
                    break;
                case "LAYOUT_HEADER":
                    this._items.push(new LayoutHeaderGeneric(block, this));
                    break;
                case "LAYOUT_FOOTER":
                    this._items.push(new LayoutFooterGeneric(block, this));
                    break;
                case "LAYOUT_KEY_VALUE":
                    this._items.push(new LayoutKeyValueGeneric(block, this));
                    break;
                case "LAYOUT_LIST":
                    this._items.push(new LayoutListGeneric(block, this));
                    break;
                case "LAYOUT_PAGE_NUMBER":
                    this._items.push(new LayoutPageNumberGeneric(block, this));
                    break;
                case "LAYOUT_SECTION_HEADER":
                    this._items.push(new LayoutSectionHeaderGeneric(block, this));
                    break;
                case "LAYOUT_TABLE":
                    this._items.push(new LayoutTableGeneric(block, this));
                    break;
                case "LAYOUT_TEXT":
                    this._items.push(new LayoutTextGeneric(block, this));
                    break;
                case "LAYOUT_TITLE":
                    this._items.push(new LayoutTitleGeneric(block, this));
                    break;
                default:
                    console.warn(`Ignoring unrecognised BlockType '${block.BlockType}' when parsing layout block ${block.Id}`);
            }
        });
    }
    get nItems() {
        return this._items.length;
    }
    get parentPage() {
        return this._parentPage;
    }
    get text() {
        return this.listItems()
            .map((item) => item.text)
            .join("\n\n");
    }
    html() {
        return this.listItems()
            .map((item) => item.html())
            .join("\n");
    }
    iterItems() {
        return (0, base_1.getIterable)(() => this.listItems());
    }
    listItems() {
        return this._items.slice();
    }
    str() {
        const content = this.listItems()
            .map((item) => item.str())
            .join("\n\n");
        return [
            "",
            "#### BEGIN PAGE LAYOUT #################",
            content,
            "#### END PAGE LAYOUT   #################",
            "",
        ].join("\n");
    }
}
exports.LayoutGeneric = LayoutGeneric;
//# sourceMappingURL=layout.js.map