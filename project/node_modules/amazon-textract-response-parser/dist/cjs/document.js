"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormsComposite = exports.TextractDocument = exports.TableTitle = exports.TableFooter = exports.Table = exports.Row = exports.MergedCell = exports.Cell = exports.QueryResult = exports.QueryInstanceCollection = exports.QueryInstance = exports.Layout = exports.LayoutList = exports.LayoutTitle = exports.LayoutText = exports.LayoutTable = exports.LayoutSectionHeader = exports.LayoutPageNumber = exports.LayoutKeyValue = exports.LayoutHeader = exports.LayoutFooter = exports.LayoutFigure = exports.Form = exports.FieldValue = exports.FieldKey = exports.Field = exports.Line = exports.Page = exports.ReadingOrderLayoutMode = exports.Word = exports.SelectionElement = exports.ApiBlockWrapper = void 0;
const base_1 = require("./api-models/base");
const base_2 = require("./base");
const content_1 = require("./content");
const form_1 = require("./form");
const geometry_1 = require("./geometry");
const layout_1 = require("./layout");
const query_1 = require("./query");
const table_1 = require("./table");
var base_3 = require("./base");
Object.defineProperty(exports, "ApiBlockWrapper", { enumerable: true, get: function () { return base_3.ApiBlockWrapper; } });
var content_2 = require("./content");
Object.defineProperty(exports, "SelectionElement", { enumerable: true, get: function () { return content_2.SelectionElement; } });
Object.defineProperty(exports, "Word", { enumerable: true, get: function () { return content_2.Word; } });
var ReadingOrderLayoutMode;
(function (ReadingOrderLayoutMode) {
    ReadingOrderLayoutMode["Auto"] = "AUTO";
    ReadingOrderLayoutMode["IgnoreLayout"] = "IGNORE_LAYOUT";
    ReadingOrderLayoutMode["RequireLayout"] = "REQUIRE_LAYOUT";
})(ReadingOrderLayoutMode || (exports.ReadingOrderLayoutMode = ReadingOrderLayoutMode = {}));
class Page extends base_2.ApiBlockWrapper {
    constructor(pageBlock, blocks, parentDocument) {
        super(pageBlock);
        this._blocks = blocks;
        this._parentDocument = parentDocument;
        this._geometry = new geometry_1.Geometry(pageBlock.Geometry, this);
        this._content = [];
        this._lines = [];
        this._tables = [];
        this._form = new form_1.FormGeneric([], this);
        this._itemsByBlockId = {};
        this._layout = new layout_1.LayoutGeneric([], this);
        this._queries = new query_1.QueryInstanceCollectionGeneric([], this);
        this._parse(blocks);
    }
    _parse(blocks) {
        this._content = [];
        this._itemsByBlockId = {};
        this._lines = [];
        this._tables = [];
        const formKeyBlocks = [];
        const layoutBlocks = [];
        const queryBlocks = [];
        blocks.forEach((item) => {
            if (item.BlockType == "LINE") {
                const l = new content_1.LineGeneric(item, this);
                this._lines.push(l);
                this._content.push(l);
                this._itemsByBlockId[l.id] = l;
            }
            else if (item.BlockType === "KEY") {
                formKeyBlocks.push(item);
            }
            else if (item.BlockType === "KEY_VALUE_SET") {
                if (item.EntityTypes.indexOf("KEY") >= 0) {
                    formKeyBlocks.push(item);
                }
            }
            else if ((0, base_1.isLayoutBlockType)(item.BlockType)) {
                layoutBlocks.push(item);
            }
            else if (item.BlockType === "QUERY") {
                queryBlocks.push(item);
            }
            else if (item.BlockType === "SELECTION_ELEMENT") {
                const s = new content_1.SelectionElement(item);
                this._itemsByBlockId[s.id] = s;
            }
            else if (item.BlockType === "SIGNATURE") {
                const sig = new content_1.Signature(item);
                this._itemsByBlockId[sig.id] = sig;
            }
            else if (item.BlockType === "TABLE") {
                const t = new table_1.TableGeneric(item, this);
                this._tables.push(t);
                this._content.push(t);
                this._itemsByBlockId[t.id] = t;
            }
            else if (item.BlockType === "WORD") {
                const w = new content_1.Word(item);
                this._itemsByBlockId[w.id] = w;
            }
        });
        this._form = new form_1.FormGeneric(formKeyBlocks, this);
        this._queries = new query_1.QueryInstanceCollectionGeneric(queryBlocks, this);
        this._layout = new layout_1.LayoutGeneric(layoutBlocks, this);
    }
    getBlockById(blockId) {
        return this._parentDocument.getBlockById(blockId);
    }
    getItemByBlockId(blockId, allowBlockTypes) {
        if (blockId === this.id)
            return this;
        const result = this._itemsByBlockId[blockId];
        if (!result) {
            throw new Error(`Missing parser item for block ID ${blockId}`);
        }
        if (allowBlockTypes) {
            const typeMatch = Array.isArray(allowBlockTypes)
                ? allowBlockTypes.indexOf(result.blockType) >= 0
                : allowBlockTypes === result.blockType;
            if (!typeMatch) {
                throw new Error(`Parser item for block ID ${blockId} had BlockType ${result.blockType} (expected ${allowBlockTypes})`);
            }
        }
        return result;
    }
    getModalWordOrientationDegrees() {
        const wordDegreesByLine = this.listLines().map((line) => line.listWords().map((word) => word.geometry.orientationDegrees()));
        const wordDegrees = []
            .concat(...wordDegreesByLine)
            .filter((n) => n != null);
        return (0, base_2.modalAvg)(wordDegrees.map((n) => Math.round(n)));
    }
    _getLineClustersByColumn({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, } = {}) {
        const paraBoxes = [];
        const paraLines = [];
        const paraTotalLineHeight = [];
        const lineHCenters = this._lines.map((l) => l.geometry.boundingBox.hCenter);
        this._lines.forEach((line, ixLine) => {
            const lineBox = line.geometry.boundingBox;
            const lineHCenter = lineHCenters[ixLine];
            let isLineHeightGarbage;
            let adjLineBox;
            if (!/[^.,_\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new geometry_1.BoundingBox({
                    Top: lineBox.top - lineBox.height * 1.5,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^-–—=~\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new geometry_1.BoundingBox({
                    Top: lineBox.top - lineBox.height * 0.75,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^'"`^\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new geometry_1.BoundingBox({
                    Top: lineBox.top,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^-–—=~.,_acemnorsuvwxz+<>:;\s]/.test(line.text)) {
                isLineHeightGarbage = false;
                adjLineBox = new geometry_1.BoundingBox({
                    Top: lineBox.top - lineBox.height * 0.25,
                    Left: lineBox.left,
                    Height: lineBox.height * 1.25,
                    Width: lineBox.width,
                }, null);
            }
            else {
                isLineHeightGarbage = false;
                adjLineBox = lineBox;
            }
            let assignedPara = null;
            for (let ixPara = 0; ixPara < paraBoxes.length; ++ixPara) {
                const paraBox = paraBoxes[ixPara];
                const paraHCenter = paraBox.hCenter;
                const nCurrParaLines = paraLines[ixPara].length;
                let newTotalLineHeight;
                let newAvgLineHeight;
                if (isLineHeightGarbage) {
                    newAvgLineHeight = paraTotalLineHeight[ixPara] / nCurrParaLines;
                    newTotalLineHeight = newAvgLineHeight * (nCurrParaLines + 1);
                }
                else {
                    newTotalLineHeight = paraTotalLineHeight[ixPara] + adjLineBox.height;
                    newAvgLineHeight = newTotalLineHeight / (nCurrParaLines + 1);
                }
                const vDist = Math.max(0, adjLineBox.top - paraBox.bottom, paraBox.top - adjLineBox.bottom);
                let passIndentationCheck;
                if (paraIndentThresh) {
                    const paraLastLine = paraLines[ixPara][nCurrParaLines - 1];
                    const paraRefLeft = paraLastLine.geometry.boundingBox.left -
                        (nCurrParaLines === 1 ? paraIndentThresh * newAvgLineHeight : 0);
                    const vIsectTop = Math.max(adjLineBox.top, paraBox.top);
                    const vIsectBottom = Math.min(adjLineBox.bottom, paraBox.bottom);
                    const vIsect = Math.max(0, vIsectBottom - vIsectTop);
                    passIndentationCheck =
                        Math.max(0, adjLineBox.left - paraRefLeft) < paraIndentThresh * newAvgLineHeight ||
                            vIsect > 0.5 * adjLineBox.height;
                }
                else {
                    passIndentationCheck = true;
                }
                if (((lineHCenter > paraBox.left && lineHCenter < paraBox.right) ||
                    (paraHCenter > lineBox.left && paraHCenter < lineBox.right)) &&
                    vDist < newAvgLineHeight * paraVDistTol &&
                    (isLineHeightGarbage ||
                        Math.abs((newAvgLineHeight - adjLineBox.height) / newAvgLineHeight) < paraLineHeightTol) &&
                    passIndentationCheck) {
                    assignedPara = ixPara;
                    paraBoxes[ixPara] = paraBox.union(lineBox);
                    paraLines[ixPara].push(line);
                    paraTotalLineHeight[ixPara] = newTotalLineHeight;
                    break;
                }
            }
            if (assignedPara == null) {
                paraBoxes.push(new geometry_1.BoundingBox(lineBox.dict));
                paraLines.push([line]);
                paraTotalLineHeight.push(lineBox.height);
            }
        });
        const colBoxes = [];
        const colParas = [];
        paraLines.forEach((para, ixPara) => {
            const paraBox = paraBoxes[ixPara];
            let assignedCol = null;
            for (let ixCol = 0; ixCol < colBoxes.length; ++ixCol) {
                const colBox = colBoxes[ixCol];
                const thisColParas = colParas[ixCol];
                const vIsectTop = Math.max(colBox.top, paraBox.top);
                const vIsectBottom = Math.min(colBox.bottom, paraBox.bottom);
                const vIsect = Math.max(0, vIsectBottom - vIsectTop);
                const hIsectLeft = Math.max(colBox.left, paraBox.left);
                const hIsectRight = Math.min(colBox.right, paraBox.right);
                const hIsect = Math.max(0, hIsectRight - hIsectLeft);
                const hUnion = Math.max(colBox.right, paraBox.right) - Math.min(colBox.left, paraBox.left);
                const minWidth = Math.min(colBox.width, paraBox.width);
                const proposedColBox = colBox.union(paraBox);
                const matchingVsSingleLine = para.length === 1 || (thisColParas.length === 1 && thisColParas[0].length === 1);
                const paraLineHeight = paraTotalLineHeight[ixPara] / paraLines[ixPara].length;
                if (vIsect < paraLineHeight * 0.1 &&
                    hIsect / minWidth >= colHOverlapThresh &&
                    (matchingVsSingleLine || hIsect / hUnion >= colHMultilineUnionThresh) &&
                    hIsect / minWidth >= colHOverlapThresh &&
                    colBoxes.filter((cbox) => cbox.intersection(proposedColBox)).length === 1) {
                    assignedCol = ixCol;
                    colBoxes[ixCol] = colBox.union(paraBox);
                    colParas[ixCol].push(para);
                    break;
                }
            }
            if (assignedCol == null) {
                colBoxes.push(new geometry_1.BoundingBox(paraBox.dict));
                colParas.push([para]);
            }
        });
        return colParas;
    }
    getLineClustersInReadingOrder({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, useLayout = "AUTO", } = {}) {
        if (this.hasLayout) {
            if (useLayout !== "IGNORE_LAYOUT") {
                return this.layout.listItems().map((item) => item.listTextLines());
            }
        }
        else if (useLayout === "REQUIRE_LAYOUT") {
            throw new Error(`Configured with useLayout=${useLayout}, but Amazon Textract Layout analysis results not found on page ${this.id}`);
        }
        return [].concat(...this._getLineClustersByColumn({
            colHOverlapThresh,
            colHMultilineUnionThresh,
            paraVDistTol,
            paraLineHeightTol,
            paraIndentThresh,
        }));
    }
    getTextInReadingOrder({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, useLayout = "AUTO", } = {}) {
        return this.getLineClustersInReadingOrder({
            colHOverlapThresh,
            colHMultilineUnionThresh,
            paraVDistTol,
            paraLineHeightTol,
            paraIndentThresh,
            useLayout,
        })
            .map((lines) => lines.map((l) => l.text).join("\n"))
            .join("\n\n");
    }
    _groupLinesByVerticalGaps(focusTop, focusHeight, lines) {
        let vGaps = [
            new geometry_1.BoundingBox({
                Top: focusTop,
                Left: this._geometry.boundingBox.left,
                Height: focusHeight,
                Width: this._geometry.boundingBox.width,
            }, null),
        ];
        let preGapLineLists = [[]];
        let postLines = [];
        (lines || this._lines).forEach((line) => {
            const lineBox = line.geometry.boundingBox;
            if (lineBox.top > vGaps[vGaps.length - 1].bottom) {
                postLines.push(line);
                return;
            }
            else if (lineBox.bottom < vGaps[0].top) {
                preGapLineLists[0].push(line);
                return;
            }
            const nextGaps = [];
            const nextPreGapLineLists = [];
            let orphanedLines = [];
            let lineAssigned = false;
            for (let ixGap = 0; ixGap < vGaps.length; ++ixGap) {
                const gap = vGaps[ixGap];
                const preGapLineList = preGapLineLists[ixGap];
                const isect = lineBox.intersection(gap);
                if (!isect) {
                    nextGaps.push(gap);
                    nextPreGapLineLists.push(orphanedLines.concat(preGapLineList));
                    orphanedLines = [];
                    continue;
                }
                else if (isect.top === gap.top && isect.height === gap.height) {
                    orphanedLines = orphanedLines.concat(preGapLineList);
                    continue;
                }
                else if (isect.top > gap.top && isect.bottom < gap.bottom) {
                    nextGaps.push(new geometry_1.BoundingBox({
                        Top: gap.top,
                        Left: gap.left,
                        Height: isect.top - gap.top,
                        Width: gap.width,
                    }, null));
                    nextPreGapLineLists.push(orphanedLines.concat(preGapLineList));
                    orphanedLines = [];
                    nextGaps.push(new geometry_1.BoundingBox({
                        Top: isect.bottom,
                        Left: gap.left,
                        Height: gap.bottom - isect.bottom,
                        Width: gap.width,
                    }, null));
                    nextPreGapLineLists.push([line]);
                    lineAssigned = true;
                }
                else {
                    const preGapLines = orphanedLines.concat(preGapLineList);
                    if (isect.top === gap.top) {
                        preGapLines.push(line);
                        lineAssigned = true;
                        nextGaps.push(new geometry_1.BoundingBox({
                            Top: gap.top + isect.height,
                            Left: gap.left,
                            Height: gap.height - isect.height,
                            Width: gap.width,
                        }, null));
                    }
                    else {
                        nextGaps.push(new geometry_1.BoundingBox({
                            Top: gap.top,
                            Left: gap.left,
                            Height: isect.top - gap.top,
                            Width: gap.width,
                        }, null));
                    }
                    nextPreGapLineLists.push(preGapLines);
                    orphanedLines = [];
                }
            }
            vGaps = nextGaps;
            preGapLineLists = nextPreGapLineLists;
            postLines = orphanedLines.concat(postLines);
            if (!lineAssigned) {
                const followGapIx = vGaps.findIndex((gap) => gap.top >= lineBox.bottom);
                if (followGapIx < 0) {
                    postLines.push(line);
                }
                else {
                    preGapLineLists[followGapIx].push(line);
                }
            }
        });
        return {
            vGaps,
            lines: preGapLineLists.concat([postLines]),
        };
    }
    _getHeaderOrFooterLines(isHeader, { maxMargin = 0.16, minGap = 0.8 } = {}, fromLines) {
        const { vGaps, lines: linesByGap } = this._groupLinesByVerticalGaps(isHeader ? this._geometry.boundingBox.top : this._geometry.boundingBox.bottom - maxMargin, maxMargin, fromLines);
        const lineGroupAvgHeights = linesByGap.map((lines) => lines.length ? lines.reduce((acc, l) => acc + l.geometry.boundingBox.height, 0) / lines.length : null);
        const nonNullLineGroupAvgHeights = lineGroupAvgHeights.filter((h) => h);
        const defaultLineHeight = nonNullLineGroupAvgHeights.reduce((acc, h) => acc + h, 0) / nonNullLineGroupAvgHeights.length;
        const gapAvgLineHeights = vGaps.map((_, ixGap) => {
            const components = [];
            const preGapHeight = lineGroupAvgHeights[ixGap];
            if (preGapHeight)
                components.push(preGapHeight);
            const postGapHeight = lineGroupAvgHeights[ixGap + 1];
            if (postGapHeight)
                components.push(postGapHeight);
            if (components.length) {
                return components.reduce((acc, h) => acc + h, 0) / components.length;
            }
            else {
                return defaultLineHeight;
            }
        });
        if (isHeader) {
            const ixSplit = vGaps.findIndex((gap, ixGap) => (ixGap > 0 || linesByGap[ixGap].length) && gap.height >= gapAvgLineHeights[ixGap] * minGap);
            return ixSplit < 0 ? [] : [].concat(...linesByGap.slice(0, ixSplit + 1));
        }
        else {
            const revLinesBygap = linesByGap.slice().reverse();
            const revGapAvgLineHeights = gapAvgLineHeights.slice().reverse();
            const ixRevSplit = vGaps
                .slice()
                .reverse()
                .findIndex((gap, ixGap) => (ixGap > 0 || revLinesBygap[ixGap].length) && gap.height >= revGapAvgLineHeights[ixGap] * minGap);
            return ixRevSplit < 0
                ? []
                : [].concat(...linesByGap.slice(vGaps.length - ixRevSplit));
        }
    }
    getFooterLines(config = {}, fromLines) {
        return this._getHeaderOrFooterLines(false, config, fromLines);
    }
    getHeaderLines(config = {}, fromLines) {
        return this._getHeaderOrFooterLines(true, config, fromLines);
    }
    getLinesByLayoutArea(inReadingOrder = false, headerConfig = {}, footerConfig = {}) {
        const sourceLines = inReadingOrder
            ? [].concat(...(inReadingOrder === true
                ? this.getLineClustersInReadingOrder()
                : this.getLineClustersInReadingOrder(inReadingOrder)))
            : this._lines;
        const sourceLineSortOrder = sourceLines.reduce((acc, next, ix) => {
            acc[next.id] = ix;
            return acc;
        }, {});
        const header = this._getHeaderOrFooterLines(true, headerConfig, sourceLines).sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]);
        let usedIds = header.reduce((acc, next) => {
            acc[next.id] = true;
            return acc;
        }, {});
        const footer = this._getHeaderOrFooterLines(false, footerConfig, sourceLines.filter((l) => !(l.id in usedIds))).sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]);
        usedIds = footer.reduce((acc, next) => {
            acc[next.id] = true;
            return acc;
        }, usedIds);
        return {
            header,
            content: sourceLines
                .filter((l) => !(l.id in usedIds))
                .sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]),
            footer,
        };
    }
    iterLines() {
        return (0, base_2.getIterable)(() => this._lines);
    }
    iterSignatures() {
        return (0, base_2.getIterable)(() => this.listSignatures());
    }
    iterTables() {
        return (0, base_2.getIterable)(() => this._tables);
    }
    lineAtIndex(ix) {
        if (ix < 0 || ix >= this._lines.length) {
            throw new Error(`Line index ${ix} must be >=0 and <${this._lines.length}`);
        }
        return this._lines[ix];
    }
    listBlocks() {
        return this._blocks.slice();
    }
    listLines() {
        return this._lines.slice();
    }
    listSignatures() {
        return this._blocks
            .filter((block) => block.BlockType === "SIGNATURE")
            .map((block) => this.getItemByBlockId(block.Id));
    }
    listTables() {
        return this._tables.slice();
    }
    registerParsedItem(blockId, item) {
        this._itemsByBlockId[blockId] = item;
    }
    tableAtIndex(ix) {
        if (ix < 0 || ix >= this._tables.length) {
            throw new Error(`Table index ${ix} must be >=0 and <${this._tables.length}`);
        }
        return this._tables[ix];
    }
    get form() {
        return this._form;
    }
    get geometry() {
        return this._geometry;
    }
    get hasLayout() {
        return this._layout.nItems > 0;
    }
    get layout() {
        return this._layout;
    }
    get nLines() {
        return this._lines.length;
    }
    get nSignatures() {
        return this.listSignatures().length;
    }
    get nTables() {
        return this._tables.length;
    }
    get pageNumber() {
        const pageIndex = this._parentDocument._pages.indexOf(this);
        if (pageIndex < 0) {
            throw new Error("parentDocument does not seem to contain this Page");
        }
        else {
            return pageIndex + 1;
        }
    }
    get parentDocument() {
        return this._parentDocument;
    }
    get queries() {
        return this._queries;
    }
    get text() {
        return this._lines.map((l) => l.text).join("\n");
    }
    html() {
        if (this.hasLayout) {
            return this._layout.html();
        }
        else {
            throw new Error("Page.html() is not yet implemented for results where Textract LAYOUT was not enabled");
        }
    }
    str() {
        return `Page\n==========\n${this._content.join("\n")}\n`;
    }
}
exports.Page = Page;
class Line extends content_1.LineGeneric {
}
exports.Line = Line;
class Field extends form_1.FieldGeneric {
}
exports.Field = Field;
class FieldKey extends form_1.FieldKeyGeneric {
}
exports.FieldKey = FieldKey;
class FieldValue extends form_1.FieldValueGeneric {
}
exports.FieldValue = FieldValue;
class Form extends form_1.FormGeneric {
}
exports.Form = Form;
class LayoutFigure extends layout_1.LayoutFigureGeneric {
}
exports.LayoutFigure = LayoutFigure;
class LayoutFooter extends layout_1.LayoutFooterGeneric {
}
exports.LayoutFooter = LayoutFooter;
class LayoutHeader extends layout_1.LayoutHeaderGeneric {
}
exports.LayoutHeader = LayoutHeader;
class LayoutKeyValue extends layout_1.LayoutKeyValueGeneric {
}
exports.LayoutKeyValue = LayoutKeyValue;
class LayoutPageNumber extends layout_1.LayoutPageNumberGeneric {
}
exports.LayoutPageNumber = LayoutPageNumber;
class LayoutSectionHeader extends layout_1.LayoutSectionHeaderGeneric {
}
exports.LayoutSectionHeader = LayoutSectionHeader;
class LayoutTable extends layout_1.LayoutTableGeneric {
}
exports.LayoutTable = LayoutTable;
class LayoutText extends layout_1.LayoutTextGeneric {
}
exports.LayoutText = LayoutText;
class LayoutTitle extends layout_1.LayoutTitleGeneric {
}
exports.LayoutTitle = LayoutTitle;
class LayoutList extends layout_1.LayoutListGeneric {
}
exports.LayoutList = LayoutList;
class Layout extends layout_1.LayoutGeneric {
}
exports.Layout = Layout;
class QueryInstance extends query_1.QueryInstanceGeneric {
}
exports.QueryInstance = QueryInstance;
class QueryInstanceCollection extends query_1.QueryInstanceCollectionGeneric {
}
exports.QueryInstanceCollection = QueryInstanceCollection;
class QueryResult extends query_1.QueryResultGeneric {
}
exports.QueryResult = QueryResult;
class Cell extends table_1.CellGeneric {
}
exports.Cell = Cell;
class MergedCell extends table_1.MergedCellGeneric {
}
exports.MergedCell = MergedCell;
class Row extends table_1.RowGeneric {
}
exports.Row = Row;
class Table extends table_1.TableGeneric {
}
exports.Table = Table;
class TableFooter extends table_1.TableFooterGeneric {
}
exports.TableFooter = TableFooter;
class TableTitle extends table_1.TableTitleGeneric {
}
exports.TableTitle = TableTitle;
class TextractDocument extends base_2.ApiObjectWrapper {
    constructor(textractResults) {
        var _a;
        let dict;
        if (Array.isArray(textractResults)) {
            dict = TextractDocument._consolidateMultipleResponses(textractResults);
        }
        else {
            if (!("Blocks" in textractResults && ((_a = textractResults.Blocks) === null || _a === void 0 ? void 0 : _a.length))) {
                throw new Error(`Provided Textract JSON has no content! (.Blocks array)`);
            }
            dict = textractResults;
        }
        super(dict);
        if ("NextToken" in this._dict && this._dict.NextToken) {
            console.warn(`Provided Textract JSON contains a NextToken: Content may be truncated!`);
        }
        this._blockMap = {};
        this._pages = [];
        this._form = new form_1.FormsCompositeGeneric([], this);
        this._parse();
    }
    _parse() {
        this._blockMap = this._dict.Blocks.reduce((acc, next) => {
            acc[next.Id] = next;
            return acc;
        }, {});
        let currentPageBlock = null;
        let currentPageContent = [];
        this._pages = [];
        this._dict.Blocks.forEach((block) => {
            if (block.BlockType == "PAGE") {
                if (currentPageBlock) {
                    this._pages.push(new Page(currentPageBlock, currentPageContent, this));
                }
                currentPageBlock = block;
                currentPageContent = [block];
            }
            else {
                currentPageContent.push(block);
            }
        });
        if (currentPageBlock) {
            this._pages.push(new Page(currentPageBlock, currentPageContent, this));
        }
        this._form = new form_1.FormsCompositeGeneric(this._pages.map((p) => p.form), this);
    }
    static _consolidateMultipleResponses(textractResultArray) {
        if (!(textractResultArray === null || textractResultArray === void 0 ? void 0 : textractResultArray.length))
            throw new Error(`Input Textract Results list empty!`);
        let nPages = 0;
        const docMetadata = { Pages: 0 };
        let blocks = [];
        let modelVersion = "";
        let analysisType = null;
        let jobStatus = null;
        let jobStatusMessage = null;
        let warnings = null;
        for (const textractResult of textractResultArray) {
            if ("Blocks" in textractResult && textractResult.Blocks) {
                blocks = blocks.concat(textractResult.Blocks);
            }
            else {
                console.warn("Found Textract response with no content");
            }
            if ("DocumentMetadata" in textractResult) {
                Object.assign(docMetadata, textractResult["DocumentMetadata"]);
                nPages = Math.max(nPages, textractResult.DocumentMetadata.Pages);
            }
            if ("AnalyzeDocumentModelVersion" in textractResult) {
                if (analysisType && analysisType !== "AnalyzeDocument") {
                    throw new Error("Inconsistent textractResults contain both AnalyzeDocument and DetectText results");
                }
                analysisType = "AnalyzeDocument";
                if (modelVersion && modelVersion !== textractResult.AnalyzeDocumentModelVersion) {
                    console.warn(`Inconsistent Textract model versions ${modelVersion} and ${textractResult.AnalyzeDocumentModelVersion}: Ignoring latter`);
                }
                else {
                    modelVersion = textractResult.AnalyzeDocumentModelVersion;
                }
            }
            if ("DetectDocumentTextModelVersion" in textractResult) {
                if (analysisType && analysisType !== "DetectText") {
                    throw new Error("Inconsistent textractResults contain both AnalyzeDocument and DetectText results");
                }
                analysisType = "DetectText";
                if (modelVersion && modelVersion !== textractResult.DetectDocumentTextModelVersion) {
                    console.warn(`Inconsistent Textract model versions ${modelVersion} and ${textractResult.DetectDocumentTextModelVersion}: Ignoring latter`);
                }
                else {
                    modelVersion = textractResult.DetectDocumentTextModelVersion;
                }
            }
            if ("JobStatus" in textractResult) {
                if (textractResult.JobStatus == "FAILED" ||
                    (textractResult.JobStatus || "").toLocaleUpperCase().indexOf("FAIL") >= 0) {
                    throw new Error(`Textract results contain failed job of status ${textractResult.JobStatus}`);
                }
                else if (jobStatus && jobStatus !== textractResult.JobStatus) {
                    throw new Error(`Textract results inconsistent JobStatus values ${jobStatus}, ${textractResult.JobStatus}`);
                }
                jobStatus = textractResult.JobStatus;
            }
            if ("StatusMessage" in textractResult && textractResult.StatusMessage) {
                if (jobStatusMessage && textractResult.StatusMessage !== jobStatusMessage) {
                    console.warn(`Multiple StatusMessages in Textract results - keeping longest`);
                    if (textractResult.StatusMessage.length > jobStatusMessage.length) {
                        jobStatusMessage = textractResult.StatusMessage;
                    }
                }
                else {
                    jobStatusMessage = textractResult.StatusMessage;
                }
            }
            if ("Warnings" in textractResult && textractResult.Warnings) {
                warnings = warnings ? warnings.concat(textractResult.Warnings) : textractResult.Warnings;
            }
        }
        const content = {
            DocumentMetadata: docMetadata,
            Blocks: blocks,
        };
        const modelVersionFields = analysisType == "AnalyzeDocument"
            ? { AnalyzeDocumentModelVersion: modelVersion }
            : analysisType == "DetectText"
                ? { DetectDocumentTextModelVersion: modelVersion }
                : { AnalyzeDocumentModelVersion: modelVersion || "Unknown" };
        const jobStatusFields = jobStatus ? { JobStatus: jobStatus } : {};
        const statusMessageFields = jobStatusMessage ? { StatusMessage: jobStatusMessage } : {};
        const warningFields = warnings ? { ArfBarf: warnings } : {};
        const lastItem = textractResultArray[textractResultArray.length - 1];
        const nextTokenFields = "NextToken" in lastItem ? { NextToken: lastItem.NextToken } : {};
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, content), modelVersionFields), jobStatusFields), statusMessageFields), warningFields), nextTokenFields);
    }
    get form() {
        return this._form;
    }
    get nPages() {
        return this._pages.length;
    }
    get text() {
        return this._pages.map((page) => page.text).join("\n\n\n\n");
    }
    getBlockById(blockId) {
        return this._blockMap && this._blockMap[blockId];
    }
    getItemByBlockId(blockId, allowBlockTypes) {
        for (const page of this._pages) {
            try {
                return page.getItemByBlockId(blockId, allowBlockTypes);
            }
            catch (_a) {
            }
        }
        throw new Error(`No parser item found on any page, for block ID ${blockId}`);
    }
    iterPages() {
        return (0, base_2.getIterable)(() => this._pages);
    }
    listBlocks() {
        return this._dict.Blocks.slice();
    }
    listPages() {
        return this._pages.slice();
    }
    pageNumber(pageNum) {
        if (!(pageNum >= 1 && pageNum <= this._pages.length)) {
            throw new Error(`pageNum ${pageNum} must be between 1 and ${this._pages.length}`);
        }
        return this._pages[pageNum - 1];
    }
    html() {
        const bodyHtml = [
            "<body>",
            (0, base_2.indent)(this._pages.map((page) => `<div class="page">\n${(0, base_2.indent)(page.html())}\n</div>`).join("\n")),
            "</body>",
        ].join("\n");
        return `<!DOCTYPE html>\n<html>\n${bodyHtml}\n</html>`;
    }
    str() {
        return `\nDocument\n==========\n${this._pages.map((p) => p.str()).join("\n\n")}\n\n`;
    }
}
exports.TextractDocument = TextractDocument;
class FormsComposite extends form_1.FormsCompositeGeneric {
}
exports.FormsComposite = FormsComposite;
//# sourceMappingURL=document.js.map