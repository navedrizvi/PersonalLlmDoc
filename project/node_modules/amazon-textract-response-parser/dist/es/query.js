import { argMax, escapeHtml, getIterable, indent, PageHostedApiBlockWrapper, } from "./base";
import { Geometry } from "./geometry";
export class QueryResultGeneric extends PageHostedApiBlockWrapper {
    constructor(block, parentQuery) {
        super(block, parentQuery.parentPage);
        this._geometry = block.Geometry ? new Geometry(block.Geometry, this) : undefined;
        this._parentQuery = parentQuery;
    }
    get confidence() {
        return this._dict.Confidence;
    }
    get geometry() {
        return this._geometry;
    }
    get parentQuery() {
        return this._parentQuery;
    }
    get text() {
        return this._dict.Text;
    }
    html() {
        return escapeHtml(this.text);
    }
    str() {
        return this.text;
    }
}
export class QueryInstanceGeneric extends PageHostedApiBlockWrapper {
    constructor(block, parentPage) {
        super(block, parentPage);
        this._parentPage = parentPage;
        this.relatedBlockIdsByRelType("ANSWER").forEach((id) => {
            const ansBlock = parentPage.getBlockById(id);
            if (!ansBlock) {
                console.warn(`Answer block ${id} referenced by QUERY block ${block.Id} is missing and will be skipped`);
            }
            else if (ansBlock.BlockType !== "QUERY_RESULT") {
                console.warn(`Expected block ${id} to be of type ${"QUERY_RESULT"} as referenced by QUERY block ${block.Id}, but got type: ${ansBlock.BlockType}`);
            }
            else {
                new QueryResultGeneric(ansBlock, this);
            }
        });
    }
    get alias() {
        return this._dict.Query.Alias;
    }
    get nResults() {
        return this._listResults().length;
    }
    get text() {
        return this._dict.Query.Text;
    }
    get topResult() {
        const results = this._listResults();
        const top = argMax(results.map((r) => r.confidence));
        if (top.maxIndex < 0)
            return undefined;
        return results[top.maxIndex];
    }
    _listResults() {
        return this.relatedBlockIdsByRelType("ANSWER")
            .map((id) => {
            try {
                return this.parentPage.getItemByBlockId(id, "QUERY_RESULT");
            }
            catch (_a) {
                return null;
            }
        })
            .filter((obj) => obj);
    }
    listResultsByConfidence() {
        return this._listResults()
            .slice()
            .sort((a, b) => b.confidence - a.confidence);
    }
    html() {
        const resultsByConf = this.listResultsByConfidence();
        const resultsHtml = resultsByConf.map((res) => `<li>${res.html()}</li>`).join("\n");
        return [
            '<div class="query">',
            indent(`<p>${escapeHtml(this.text)}</p>`),
            indent(resultsByConf.length ? ["<ul>", indent(resultsHtml), "</ul>"].join("\n") : "<ul></ul>"),
            "</div>",
        ].join("\n");
    }
    str() {
        return `Query\n==========\nQuestion: ${this.text}\nAnswers:\n - ${this.listResultsByConfidence()
            .map((r) => r.text)
            .join("\n - ")}`;
    }
}
export class QueryInstanceCollectionGeneric {
    constructor(queryBlocks, parentPage) {
        this._queries = [];
        this._parentPage = parentPage;
        queryBlocks.forEach((queryBlock) => {
            this._queries.push(new QueryInstanceGeneric(queryBlock, parentPage));
        });
    }
    get nQueries() {
        return this._queries.length;
    }
    get parentPage() {
        return this._parentPage;
    }
    get text() {
        return this._queries
            .map((query) => `${query.text}\n${query
            .listResultsByConfidence()
            .map((r) => r.text)
            .join("\n")}`)
            .join("\n\n");
    }
    getQueryByAlias(alias) {
        if (!alias)
            return;
        return this._queries.find((q) => q.alias === alias);
    }
    getQueryByQuestion(question) {
        if (!question)
            return;
        return this._queries.find((q) => q.text === question);
    }
    html() {
        return ['<div class="queries">', indent(this._queries.map((q) => q.html()).join("\n")), "</div>"].join("\n");
    }
    iterQueries(opts = {}) {
        return getIterable(() => this.listQueries(opts));
    }
    listQueries(opts = {}) {
        return opts.skipUnanswered ? this._queries.filter((q) => q.nResults > 0) : this._queries.slice();
    }
    searchQueriesByAlias(alias, opts = {}) {
        if (!alias)
            return [];
        const searchKey = alias.toLowerCase();
        return this.listQueries(opts).filter((q) => q.alias && q.alias.toLowerCase().indexOf(searchKey) >= 0);
    }
    searchQueriesByQuestion(question, opts = {}) {
        if (!question)
            return [];
        const searchKey = question.toLowerCase();
        return this.listQueries(opts).filter((q) => q.text.toLowerCase().indexOf(searchKey) >= 0);
    }
    str() {
        return this._queries.map((q) => q.str()).join("\n");
    }
}
//# sourceMappingURL=query.js.map