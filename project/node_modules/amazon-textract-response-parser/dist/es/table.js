import { aggregate, escapeHtml, getIterable, indent, PageHostedApiBlockWrapper, } from "./base";
import { buildWithContent, WithWords } from "./content";
import { Geometry } from "./geometry";
class CellBaseGeneric extends PageHostedApiBlockWrapper {
    constructor(block, parentTable) {
        super(block, parentTable.parentPage);
        this._geometry = new Geometry(block.Geometry, this);
        this._parentTable = parentTable;
    }
    get geometry() {
        return this._geometry;
    }
    get parentTable() {
        return this._parentTable;
    }
}
function WithCellBaseProps(SuperClass) {
    return class extends SuperClass {
        get columnIndex() {
            return this.dict.ColumnIndex;
        }
        get columnSpan() {
            return this.dict.ColumnSpan || 1;
        }
        get confidence() {
            return this.dict.Confidence;
        }
        set confidence(newVal) {
            this.dict.Confidence = newVal;
        }
        get rowIndex() {
            return this.dict.RowIndex;
        }
        get rowSpan() {
            return this.dict.RowSpan || 1;
        }
        getOcrConfidence(aggMethod = "MEAN") {
            return aggregate(this.listContent().map((c) => c.confidence), aggMethod);
        }
        hasEntityTypes(entityType) {
            if (!this.dict.EntityTypes)
                return null;
            if (Array.isArray(entityType)) {
                return entityType.some((eType) => this.dict.EntityTypes.indexOf(eType) >= 0);
            }
            return this.dict.EntityTypes.indexOf(entityType) >= 0;
        }
        html() {
            const tagName = this.hasEntityTypes([
                "COLUMN_HEADER",
                "TABLE_SECTION_TITLE",
                "TABLE_TITLE",
            ])
                ? "th"
                : "td";
            return indent([
                "<",
                tagName,
                this.columnSpan > 1 ? ` colspan="${this.columnSpan}"` : "",
                this.rowSpan > 1 ? ` rowspan="${this.rowSpan}"` : "",
                ">",
                escapeHtml(this.text),
                `</${tagName}>`,
            ].join(""), { skipFirstLine: true });
        }
        str() {
            return this.text;
        }
    };
}
export class CellGeneric extends WithCellBaseProps(buildWithContent()(CellBaseGeneric)) {
    constructor(block, parentTable) {
        super(block, parentTable);
        this._geometry = new Geometry(block.Geometry, this);
        this.childBlockIds.forEach((cid) => {
            if (!this.parentPage.getBlockById(cid)) {
                console.warn(`Document missing child block ${cid} referenced by table cell ${this.id}`);
            }
        });
    }
}
export class MergedCellGeneric extends WithCellBaseProps(buildWithContent()(CellBaseGeneric)) {
    constructor(block, parentTable) {
        super(block, parentTable);
        this._geometry = new Geometry(block.Geometry, this);
    }
    get nSubCells() {
        return this.listSubCells().length;
    }
    listSubCells() {
        return this.childBlockIds.map((cid) => this.parentTable._getSplitCellByBlockId(cid));
    }
    iterContent() {
        const getIterator = () => {
            const cells = this.listSubCells();
            const tryListCellContents = (ixCell) => cells.length > ixCell ? cells[ixCell].listContent() : [];
            let ixCurrCell = 0;
            let cellContents = tryListCellContents(ixCurrCell);
            let ixCurrItem = -1;
            return {
                next: () => {
                    ++ixCurrItem;
                    while (ixCurrItem >= cellContents.length) {
                        ++ixCurrCell;
                        ixCurrItem = 0;
                        if (ixCurrCell >= cells.length)
                            return { done: true, value: undefined };
                        cellContents = tryListCellContents(ixCurrCell);
                    }
                    return { done: false, value: cellContents[ixCurrItem] };
                },
            };
        };
        return {
            [Symbol.iterator]: getIterator,
        };
    }
    listContent() {
        return [].concat(...this.listSubCells().map((c) => c.listContent()));
    }
    iterSubCells() {
        return getIterable(() => this.listSubCells());
    }
}
export class RowGeneric {
    constructor(cells = [], parentTable) {
        this._cells = cells;
        this._parentTable = parentTable;
    }
    get nCells() {
        return this._cells.length;
    }
    get parentTable() {
        return this._parentTable;
    }
    get text() {
        return this._cells.map((cell) => cell.text).join("\t");
    }
    getConfidence(aggMethod = "MEAN") {
        return aggregate(this._cells.map((c) => c.confidence), aggMethod);
    }
    getOcrConfidence(aggMethod = "MEAN") {
        const contentConfs = [].concat(...this._cells.map((cell) => cell.listContent().map((content) => content.confidence)));
        return aggregate(contentConfs, aggMethod);
    }
    iterCells() {
        return getIterable(() => this._cells);
    }
    listCells() {
        return this._cells.slice();
    }
    str() {
        return this._cells.map((cell) => `[${cell.str()}]`).join("");
    }
}
export class TableFooterGeneric extends WithWords(PageHostedApiBlockWrapper) {
    get confidence() {
        return this._dict.Confidence;
    }
    html() {
        return escapeHtml(this.text);
    }
    str() {
        return `==== [Table footer] ====\n${this.text}\n========================`;
    }
}
export class TableTitleGeneric extends WithWords(PageHostedApiBlockWrapper) {
    get confidence() {
        return this._dict.Confidence;
    }
    html() {
        return escapeHtml(this.text);
    }
    str() {
        return `==== [Table header] ====\n${this.text}\n========================`;
    }
}
export class TableGeneric extends PageHostedApiBlockWrapper {
    constructor(block, parentPage) {
        super(block, parentPage);
        this._geometry = new Geometry(block.Geometry, this);
        this._cells = [];
        for (const rs of block.Relationships) {
            const itemBlocks = rs.Ids.map((cid) => {
                const cblk = parentPage.getBlockById(cid);
                if (!cblk) {
                    console.warn(`Document missing related block ${cid} referenced by TABLE ${this.id}`);
                    return;
                }
                return cblk;
            }).filter((cblk) => cblk);
            if (rs.Type === "CHILD") {
                this._cells = this._cells.concat(itemBlocks.map((cblk) => new CellGeneric(cblk, this)));
            }
            else if (rs.Type === "TABLE_FOOTER") {
                itemBlocks.map((cblk) => new TableFooterGeneric(cblk, parentPage));
            }
            else if (rs.Type === "TABLE_TITLE") {
                itemBlocks.map((cblk) => new TableTitleGeneric(cblk, parentPage));
            }
            else if (rs.Type !== "MERGED_CELL") {
                console.warn(`TABLE ${this.id} contained a relationship of unexpected type '${rs.Type}' which will be ignored`);
            }
        }
        this._sortCellsByLocation(this._cells);
        this._nCols = this._cells.reduce((acc, next) => Math.max(acc, next.columnIndex + next.columnSpan - 1), 0);
        this._nRows = this._cells.reduce((acc, next) => Math.max(acc, next.rowIndex + next.rowSpan - 1), 0);
        this._cellsById = {};
        this._updateCellsById();
        this._mergedCells = [].concat(...(block.Relationships || [])
            .filter((rs) => rs.Type == "MERGED_CELL")
            .map((rs) => rs.Ids.map((cid) => {
            const cellBlock = parentPage.getBlockById(cid);
            if (!cellBlock) {
                return;
            }
            return new MergedCellGeneric(cellBlock, this);
        }).filter((cell) => cell)));
    }
    _sortCellsByLocation(cells) {
        cells.sort((a, b) => a.rowIndex - b.rowIndex || a.columnIndex - b.columnIndex);
    }
    _updateCellsById() {
        this._cellsById = this._cells.reduce((acc, next) => {
            acc[next.id] = next;
            return acc;
        }, {});
    }
    _getSplitCellByBlockId(id) {
        let result = this._cellsById[id];
        if (result) {
            return result;
        }
        else {
            this._updateCellsById();
            result = this._cellsById[id];
            if (!result) {
                throw new Error(`Referenced cell ID ${id} missing from TABLE ${this.id}`);
            }
            return result;
        }
    }
    cellAt(rowIndex, columnIndex, opts = {}) {
        const ignoreMerged = opts.ignoreMerged || false;
        const mergedResult = !ignoreMerged &&
            this._mergedCells.find((c) => c.columnIndex <= columnIndex &&
                c.columnIndex + c.columnSpan > columnIndex &&
                c.rowIndex <= rowIndex &&
                c.rowIndex + c.rowSpan > rowIndex);
        if (mergedResult) {
            return mergedResult;
        }
        else {
            return this._cells.find((c) => c.columnIndex === columnIndex && c.rowIndex === rowIndex);
        }
    }
    cellsAt(rowIndex, columnIndex, opts = {}) {
        const ignoreMerged = opts.ignoreMerged || false;
        const mergedCells = ignoreMerged
            ? []
            : this._mergedCells.filter((c) => (rowIndex == null || (c.rowIndex <= rowIndex && c.rowIndex + c.rowSpan > rowIndex)) &&
                (columnIndex == null ||
                    (c.columnIndex <= columnIndex && c.columnIndex + c.columnSpan > columnIndex)));
        const mergedCellChildIds = mergedCells.reduce((acc, next) => {
            next.listSubCells().forEach((c) => {
                acc[c.id] = true;
            });
            return acc;
        }, {});
        const rawCells = this._cells.filter((c) => (rowIndex == null || c.rowIndex === rowIndex) &&
            (columnIndex == null || c.columnIndex === columnIndex) &&
            !(c.id in mergedCellChildIds));
        const result = mergedCells.concat(rawCells);
        this._sortCellsByLocation(result);
        return result;
    }
    getOcrConfidence(aggMethod = "MEAN") {
        const contentConfs = [].concat(...this._cells.map((cell) => cell.listContent().map((content) => content.confidence)));
        return aggregate(contentConfs, aggMethod);
    }
    iterFooters() {
        return getIterable(() => this.listFooters());
    }
    iterRows(opts = {}) {
        const getIterator = () => {
            let ixRow = 0;
            return {
                next: () => {
                    if (ixRow < this._nRows) {
                        return {
                            done: false,
                            value: this.rowAt(++ixRow, opts),
                        };
                    }
                    else {
                        return {
                            done: true,
                            value: undefined,
                        };
                    }
                },
            };
        };
        return {
            [Symbol.iterator]: getIterator,
        };
    }
    iterTitles() {
        return getIterable(() => this.listTitles());
    }
    listFooters() {
        return this.relatedBlockIdsByRelType("TABLE_FOOTER").map((id) => this.parentPage.getItemByBlockId(id));
    }
    listRows(opts = {}) {
        return [...Array(this._nRows).keys()].map((ixRow) => this.rowAt(ixRow + 1, opts));
    }
    listTitles() {
        return this.relatedBlockIdsByRelType("TABLE_TITLE").map((id) => this.parentPage.getItemByBlockId(id));
    }
    rowAt(rowIndex, opts = {}) {
        const repeatMultiRowCells = opts.repeatMultiRowCells || false;
        const allRowCells = this.cellsAt(rowIndex, null, { ignoreMerged: opts.ignoreMerged });
        return new RowGeneric(repeatMultiRowCells ? allRowCells : allRowCells.filter((c) => c.rowIndex === rowIndex), this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get firstFooter() {
        const footers = this.listFooters();
        return footers.length ? footers[0] : undefined;
    }
    get firstTitle() {
        const titles = this.listTitles();
        return titles.length ? titles[0] : undefined;
    }
    get geometry() {
        return this._geometry;
    }
    get nCells() {
        const nMergeTargets = this._mergedCells.map((mc) => mc.nSubCells).reduce((acc, next) => acc + next, 0);
        return this._cells.length + this._mergedCells.length - nMergeTargets;
    }
    get nColumns() {
        return this._nCols;
    }
    get nRows() {
        return this._nRows;
    }
    get tableType() {
        if (!this._dict.EntityTypes)
            return null;
        const isStructured = this._dict.EntityTypes.indexOf("STRUCTURED_TABLE") >= 0;
        const isSemiStructured = this._dict.EntityTypes.indexOf("SEMI_STRUCTURED_TABLE") >= 0;
        const nMatches = +isStructured + +isSemiStructured;
        if (nMatches === 0)
            return null;
        if (nMatches > 1) {
            throw new Error(`TABLE block ${this._dict.Id} EntityTypes contained multiple conflicting table types: "${this._dict.EntityTypes}"`);
        }
        if (isStructured)
            return "STRUCTURED_TABLE";
        return "SEMI_STRUCTURED_TABLE";
    }
    get text() {
        return this.listRows()
            .map((row) => row.text)
            .join("\n");
    }
    html() {
        const rowHtmls = this.listRows().map((row) => [
            "<tr>",
            indent(row
                .listCells()
                .map((cell) => cell.html())
                .join("\n")),
            "</tr>",
        ].join("\n"));
        const titleTexts = this.listTitles().map((item) => item.html());
        const footerTexts = this.listFooters().map((item) => item.html());
        if (titleTexts.length && footerTexts.length) {
            const titleInnerHtml = titleTexts.length > 1 ? titleTexts.map((text) => `<p>${text}</p>`).join("\n") : titleTexts[0];
            const footerInnerHtml = titleTexts.length > 1 ? titleTexts.map((text) => `<p>${text}</p>`).join("\n") : titleTexts[0];
            return [
                '<div class="table-wrapper">',
                indent([
                    '<div class="table-title">',
                    indent(titleInnerHtml),
                    "</div>",
                    "<table>",
                    indent(rowHtmls.join("\n")),
                    "</table>",
                    '<div class="table-footer">',
                    indent(footerInnerHtml),
                    "</div>",
                ].join("\n")),
                "</div>",
            ].join("\n");
        }
        else if (!(titleTexts.length || footerTexts.length)) {
            return `<table>\n${indent(rowHtmls.join("\n"))}\n</table>`;
        }
        else {
            const isTitle = titleTexts.length != 0;
            const captionTexts = isTitle ? titleTexts : footerTexts;
            const captionHtml = captionTexts.length > 1 ? captionTexts.map((text) => `<p>${text}</p>`).join("\n") : captionTexts[0];
            const innerHtml = [
                `<caption style="caption-side: ${isTitle ? "top" : "bottom"}">`,
                indent(captionHtml),
                "</caption>",
            ]
                .concat(rowHtmls)
                .join("\n");
            return `<table>\n${indent(innerHtml)}\n</table>`;
        }
    }
    str() {
        return ("Table\n==========\n" +
            this.listRows()
                .map((row) => `Row\n==========\n${row.str()}`)
                .join("\n"));
    }
}
//# sourceMappingURL=table.js.map