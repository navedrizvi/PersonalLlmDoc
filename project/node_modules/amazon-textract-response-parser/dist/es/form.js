import { aggregate, escapeHtml, getIterable, indent, PageHostedApiBlockWrapper, } from "./base";
import { buildWithContent, WithWords } from "./content";
import { Geometry } from "./geometry";
export class FieldKeyGeneric extends WithWords(PageHostedApiBlockWrapper) {
    constructor(block, parentField) {
        super(block, parentField.parentPage);
        this._parentField = parentField;
        this._geometry = new Geometry(block.Geometry, this);
    }
    get geometry() {
        return this._geometry;
    }
    get parentField() {
        return this._parentField;
    }
    get confidence() {
        return this._dict.Confidence;
    }
    getOcrConfidence(aggMethod = "MEAN") {
        return aggregate(this.listWords().map((w) => w.confidence), aggMethod);
    }
    html() {
        return escapeHtml(this.text);
    }
    str() {
        return this.text;
    }
}
export class FieldValueGeneric extends buildWithContent()(PageHostedApiBlockWrapper) {
    constructor(valueBlock, parentField) {
        super(valueBlock, parentField.parentPage);
        this._parentField = parentField;
        this._geometry = new Geometry(valueBlock.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    get geometry() {
        return this._geometry;
    }
    get parentField() {
        return this._parentField;
    }
    getOcrConfidence(aggMethod = "MEAN") {
        return aggregate(this.listContent().map((c) => c.confidence), aggMethod);
    }
    html() {
        return escapeHtml(this.text);
    }
    str() {
        return this.text;
    }
}
export class FieldGeneric {
    constructor(keyBlock, parentForm) {
        this._parentForm = parentForm;
        this._value = null;
        this._key = new FieldKeyGeneric(keyBlock, this);
        let valueBlockIds = [];
        (keyBlock.Relationships || []).forEach((rs) => {
            if (rs.Type == "VALUE") {
                valueBlockIds = valueBlockIds.concat(rs.Ids);
            }
        });
        if (valueBlockIds.length > 1) {
            const fieldLogName = this._key ? `field '${this._key.text}'` : "unnamed form field";
            console.warn(`Got ${valueBlockIds.length} value blocks for ${fieldLogName} (Expected 0-1). Including first only.`);
        }
        if (valueBlockIds.length) {
            const valBlockId = valueBlockIds[0];
            const valBlock = parentForm.parentPage.getBlockById(valBlockId);
            if (!valBlock) {
                console.warn(`Document missing child block ${valBlockId} referenced by value for field key ${this.key.id}`);
            }
            else {
                this._value = new FieldValueGeneric(valBlock, this);
            }
        }
    }
    get blockType() {
        return this._key.blockType;
    }
    get confidence() {
        const scores = [];
        if (this._key) {
            scores.push(this._key.confidence || 0);
        }
        if (this._value) {
            scores.push(this._value.confidence || 0);
        }
        if (scores.length) {
            return scores.reduce((acc, next) => acc + next, 0) / scores.length;
        }
        else {
            return 0;
        }
    }
    get childBlockIds() {
        return this._key.childBlockIds;
    }
    get dict() {
        return this._key.dict;
    }
    get id() {
        return this._key.id;
    }
    get key() {
        return this._key;
    }
    get parentForm() {
        return this._parentForm;
    }
    get parentPage() {
        return this._parentForm.parentPage;
    }
    get text() {
        var _a;
        return `${this._key.text}: ${((_a = this._value) === null || _a === void 0 ? void 0 : _a.text) || ""}`;
    }
    get value() {
        return this._value;
    }
    getOcrConfidence(aggMethod = "MEAN") {
        const keyValContent = (this._value ? this._value.listContent() : []).concat(this._key.listWords());
        return aggregate(keyValContent.map((c) => c.confidence), aggMethod);
    }
    relatedBlockIdsByRelType(relType) {
        return this._key.relatedBlockIdsByRelType(relType);
    }
    html() {
        var _a;
        return `<input label="${escapeHtml(this._key.text, {
            forAttr: true,
        })}" type="text" disabled value="${escapeHtml(((_a = this._value) === null || _a === void 0 ? void 0 : _a.text) || "", { forAttr: true })}" />`;
    }
    str() {
        return `\nField\n==========\nKey: ${this._key ? this._key.str() : ""}\nValue: ${this._value ? this._value.str() : ""}`;
    }
}
export class FormGeneric {
    constructor(keyBlocks, parentPage) {
        this._fields = [];
        this._fieldsMap = {};
        this._parentPage = parentPage;
        keyBlocks.forEach((keyBlock) => {
            const f = new FieldGeneric(keyBlock, this);
            this._fields.push(f);
            const fieldKeyText = f.key.text || "";
            if (fieldKeyText) {
                if (fieldKeyText in this._fieldsMap) {
                    if (f.confidence > this._fieldsMap[fieldKeyText].confidence) {
                        this._fieldsMap[fieldKeyText] = f;
                    }
                }
                else {
                    this._fieldsMap[fieldKeyText] = f;
                }
            }
        });
    }
    get nFields() {
        return this._fields.length;
    }
    get parentPage() {
        return this._parentPage;
    }
    get text() {
        return this.listFields()
            .map((f) => f.text)
            .join("\n");
    }
    getFieldByKey(key) {
        return this._fieldsMap[key] || null;
    }
    html() {
        return `<form>\n${indent(this.listFields()
            .map((f) => f.html())
            .join("\n"))}\n</form>`;
    }
    iterFields(skipFieldsWithoutKey = false) {
        return getIterable(() => this.listFields(skipFieldsWithoutKey));
    }
    listFields(skipFieldsWithoutKey = false) {
        return skipFieldsWithoutKey ? this._fields.filter((f) => f.key) : this._fields.slice();
    }
    searchFieldsByKey(key) {
        const searchKey = key.toLowerCase();
        return this._fields.filter((field) => field.key && field.key.text.toLowerCase().indexOf(searchKey) >= 0);
    }
    str() {
        return this._fields.map((f) => f.str()).join("\n");
    }
}
export class FormsCompositeGeneric {
    constructor(forms, parentDocument) {
        this._forms = forms;
        this._parentDocument = parentDocument;
    }
    get nFields() {
        return this._forms.reduce((acc, next) => acc + next.nFields, 0);
    }
    get parentDocument() {
        return this._parentDocument;
    }
    get text() {
        return this._forms.map((f) => f.text).join("\n\n");
    }
    getFieldByKey(key) {
        for (const form of this._forms) {
            const result = form.getFieldByKey(key);
            if (result)
                return result;
        }
        return null;
    }
    html() {
        const pageHtmls = this._forms.map((form, ixForm) => `<div class="form-page" id="form-page-${ixForm}">\n${indent(form
            .listFields()
            .map((f) => `${f.html()}\n`)
            .join(""))}</div>\n`);
        return `<form>\n${indent(pageHtmls.join(""))}</form>`;
    }
    iterFields(skipFieldsWithoutKey = false) {
        return getIterable(() => this.listFields(skipFieldsWithoutKey));
    }
    listFields(skipFieldsWithoutKey = false) {
        const allFields = [].concat(...this._forms.map((form) => form.listFields()));
        if (skipFieldsWithoutKey) {
            return allFields.filter((f) => f.key);
        }
        else {
            return allFields;
        }
    }
    searchFieldsByKey(key) {
        return [].concat(...this._forms.map((f) => f.searchFieldsByKey(key)));
    }
    str() {
        return this._forms.map((f) => f.str()).join("\n");
    }
}
//# sourceMappingURL=form.js.map