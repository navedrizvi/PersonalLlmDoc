/**
 * TRP classes for (generic document) layout analysis objects
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
import { ApiBlockType } from "./api-models/base";
import { ApiBlock } from "./api-models/document";
import { ApiLayoutBlock, ApiLayoutFigureBlock, ApiLayoutFooterBlock, ApiLayoutHeaderBlock, ApiLayoutKeyValueBlock, ApiLayoutListBlock, ApiLayoutPageNumberBlock, ApiLayoutSectionHeaderBlock, ApiLayoutTableBlock, ApiLayoutTextBlock, ApiLayoutTitleBlock } from "./api-models/layout";
import { ApiObjectWrapper, IApiBlockWrapper, IBlockManager, IRenderable, IWithParentPage, PageHostedApiBlockWrapper } from "./base";
import { IWithContent, LineGeneric } from "./content";
import { FieldGeneric, IWithForm } from "./form";
import { Geometry, IWithGeometry } from "./geometry";
import { IWithTables, TableGeneric } from "./table";
/**
 * Standard interface for parsed Layout items
 */
export interface ILayoutItem<TBlock extends ApiLayoutBlock, TContent extends IApiBlockWrapper<ApiBlock> & IRenderable, TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>, TGeometryHost extends ApiObjectWrapper<TBlock>> extends IApiBlockWrapper<TBlock>, IRenderable, IWithContent<TContent>, IWithParentPage<TPage>, IWithGeometry<TBlock, TGeometryHost> {
    /**
     * 0-100 based confidence of the layout model for this element (*separate* from OCR confidence!)
     */
    confidence: number;
    /**
     * Position of this layout element on the input image/page
     */
    geometry: Geometry<TBlock, TGeometryHost>;
    /**
     * Number of text `Line`s in this object
     */
    get nTextLines(): number;
    /**
     * Parsed page layout collection that this element belongs to
     */
    parentLayout: LayoutGeneric<TPage>;
    /**
     * Iterate through the text `Line`s in this object
     * @example
     * for (const line of layItem.iterTextLines()) {
     *   console.log(line.text);
     * }
     * @example
     * [...layItem.iterTextLines()].forEach(
     *   (line) => console.log(line.text)
     * );
     */
    iterTextLines(): Iterable<LineGeneric<TPage>>;
    /**
     * List the text `Line` items in this object
     */
    listTextLines(): Array<LineGeneric<TPage>>;
}
/**
 * Generic class on which layout items are based
 */
declare class LayoutItemBaseGeneric<TBlock extends ApiLayoutBlock, TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends PageHostedApiBlockWrapper<TBlock, TPage> implements IWithGeometry<TBlock, LayoutItemBaseGeneric<TBlock, TPage>>, IWithParentPage<TPage> {
    _geometry: Geometry<ApiLayoutBlock, LayoutItemBaseGeneric<TBlock, TPage>>;
    _parentLayout: LayoutGeneric<TPage>;
    constructor(block: TBlock, parentLayout: LayoutGeneric<TPage>);
    get confidence(): number;
    get geometry(): Geometry<ApiLayoutBlock, LayoutItemBaseGeneric<TBlock, TPage>>;
    get parentLayout(): LayoutGeneric<TPage>;
}
declare const LayoutLineContainerItem_base: {
    new (...args: any[]): {
        iterContent(): Iterable<LineGeneric<IBlockManager>>;
        listContent(): LineGeneric<IBlockManager>[];
        readonly nContentItems: number;
        get text(): string;
        readonly dict: ApiBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: import("./api-models/base").ApiRelationshipType | import("./api-models/base").ApiRelationshipType[]): string[];
        parentPage: IBlockManager;
    };
} & typeof LayoutItemBaseGeneric;
/**
 * Common base class for Layout items whose `Child`ren are always text LINEs
 *
 * Not a big fan of relying heavily on this level of hierarchy because of its fragility... But at
 * the moment it seems like almost every Layout item contains only text `LINE` blocks, and it'd be
 * better to represent the `.text` of these as newline-joined rather than the default space-joined
 * from the mixin... So for now this helps us reduce some code duplication.
 */
declare class LayoutLineContainerItem<TBlock extends ApiLayoutBlock, TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem_base<TBlock, TPage> {
    /**
     * Iterate through the text `Line`s in this object
     *
     * (Should be equivalent to iterContent, for LayoutLineContainer items that only contain text
     * LINE objects)
     *
     * @example
     * for (const line of layItem.iterTextLines()) {
     *   console.log(line.text);
     * }
     * @example
     * [...layItem.iterTextLines()].forEach(
     *   (line) => console.log(line.text)
     * );
     */
    iterTextLines(): Iterable<LineGeneric<TPage>>;
    /**
     * List the text `Line` items in this object
     *
     * (Should be equivalent to listContent, for LayoutLineContainer items that only contain text
     * LINE objects)
     */
    listTextLines(): Array<LineGeneric<TPage>>;
    /**
     * Number of text `Line`s in this object
     *
     * (Should be equivalent to nContentItems, for LayoutLineContainer items that only contain text
     * LINE objects)
     */
    get nTextLines(): number;
    /**
     * The text representation of this element concatenates child text `Line`s, separated by newlines
     */
    get text(): string;
}
/**
 * Generic base class for a layout entity describing a diagram, figure, or image
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutFigure`.
 */
export declare class LayoutFigureGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutFigureBlock, TPage> implements ILayoutItem<ApiLayoutFigureBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutFigureBlock, TPage>> {
    /**
     * The semantic HTML representation for a figure is a <div> of class `figure`
     *
     * Detected text within the figure (if any), is included inside the div
     */
    html(): string;
    /**
     * The str() representation of a figure allows including text, but usually doesn't have any
     */
    str(): string;
}
/**
 * Generic base class for a layout entity describing a page footer element
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutFooter`.
 */
export declare class LayoutFooterGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutFooterBlock, TPage> implements ILayoutItem<ApiLayoutFooterBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutFooterBlock, TPage>> {
    /**
     * The semantic HTML representation for a Footer element is a <div> of class `footer-el`
     *
     * Note that there might be multiple footer elements on a page (e.g. horizontal columns)
     */
    html(): string;
    str(): string;
}
/**
 * Generic base class for a layout entity describing a page header element
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutHeader`.
 */
export declare class LayoutHeaderGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutHeaderBlock, TPage> implements ILayoutItem<ApiLayoutHeaderBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutHeaderBlock, TPage>> {
    /**
     * The semantic HTML representation for a Footer element is a <div> of class `footer-el`
     *
     * Note that there might be multiple footer elements on a page (e.g. horizontal columns)
     */
    html(): string;
    str(): string;
}
/**
 * Generic base class for a layout entity describing a key-value (form data) pair
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutKeyValue`.
 */
export declare class LayoutKeyValueGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutKeyValueBlock, TPage> implements ILayoutItem<ApiLayoutKeyValueBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutKeyValueBlock, TPage>> {
    /**
     * Utility function to list all content (word, signature, etc) block IDs within a K-V Form Field
     *
     * Used to support mapping between Layout and K-V Forms objects e.g. in
     * `_mapPageContentToFormFields()`
     *
     * @param field Parsed TRP.js `Field` object from forms analysis
     * @returns Snapshot list of all the content (word, etc) block IDs in the Field's Key and Value
     */
    protected _listContentIdsInFormField<TPage extends IBlockManager>(field: FieldGeneric<TPage>): string[];
    /**
     * Utility function to generate a (point-in-time) mapping from field K/V content to field objects
     *
     * Since Textract JSON only stores one-way mappings from Key->WORD, Key->Value, and
     * Value->(WORD/SELECTION_ELEMENT/SIGNATURE), and from LAYOUT_KEY_VALUE->LINE->WORD, we need to
     * calculate some inverse mappings to enable searches to link from Layout to form Fields.
     *
     * TODO: If this has utility elsewhere, move it to FormGeneric and consider caching?
     */
    protected _mapPageContentToFormFields(): {
        [blockId: string]: FieldGeneric<TPage>;
    };
    /**
     * Iterate through the Form Fields spanned by this LayoutKeyValue item
     *
     * Note this is a non-trivial lookup that requires searching through associated WORD blocks, due
     * to the structure of Textract responses. If Textract FORMS analysis was not also enabled in the
     * API, this will return an empty list [].
     *
     * @example
     * for (const field of form.iterFields()) {
     *   console.log(field?.key.text);
     * }
     * @example
     * const fields = [...form.iterFields()];
     */
    iterFields(): Iterable<FieldGeneric<TPage>>;
    /**
     * List the Form Fields spanned by this LayoutKeyValue item
     *
     * Note this is a non-trivial lookup that requires searching through associated WORD blocks, due
     * to the structure of Textract responses. If Textract FORMS analysis was not also enabled in the
     * API, this will return an empty list [].
     */
    listFields(): FieldGeneric<TPage>[];
    /**
     * The semantic HTML representation for a key-value element is a <div> of class "key-value"
     *
     * Note this attempts to reconcile the contained content to Forms analysis' Key-Value pairs for
     * optimally semantic HTML, *if* the Forms feature was also enabled - but this is a non-trivial
     * operation.
     *
     * Since there's no guaranteed 1:1 correspondence between Layout K-V regions and detected form
     * fields, we loop through the plain text (from layout) but insert the semantic HTML for a whole
     * K-V Form Field at the first overlapping mention.
     */
    html(): string;
    /**
     * The human-readable `str()` representation for this element does not do KV Forms reconciliation
     *
     * It just returns the Layout object's `text` with some bookends for clarity.
     */
    str(): string;
}
/**
 * Generic base class for a layout entity describing a page number annotation
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutPageNumber`.
 */
export declare class LayoutPageNumberGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutPageNumberBlock, TPage> implements ILayoutItem<ApiLayoutPageNumberBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutPageNumberBlock, TPage>> {
    /**
     * The semantic HTML representation for a page number element is a <div> of class "page-num"
     */
    html(): string;
    str(): string;
}
/**
 * Generic base class for a layout entity describing a section heading / title
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutSectionHeader`.
 */
export declare class LayoutSectionHeaderGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutSectionHeaderBlock, TPage> implements ILayoutItem<ApiLayoutSectionHeaderBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutSectionHeaderBlock, TPage>> {
    /**
     * The semantic HTML representation for a section heading is a <h2> tag
     */
    html(): string;
    str(): string;
}
/**
 * Generic base class for a layout entity describing a table
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutTable`.
 */
export declare class LayoutTableGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutTableBlock, TPage> implements ILayoutItem<ApiLayoutTableBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutTableBlock, TPage>> {
    /**
     * Utility function to list all content (word, signature, etc) block IDs within a parsed Table object
     *
     * Used to support mapping between Layout and Tables analysis objects e.g. in
     * `_mapPageContentToTables()`
     *
     * @param field Parsed TRP.js `Field` object from forms analysis
     * @returns Snapshot list of all the content (word, etc) block IDs in the Field's Key and Value
     */
    protected _listContentIdsInTable<TPage extends IBlockManager>(table: TableGeneric<TPage>): string[];
    /**
     * Utility function to generate a (point-in-time) mapping from table content to Table objects
     *
     * Since Textract JSON only stores one-way mappings from CELL/MERGED_CELL->WORD, TABLE->CELL etc,
     * we need to calculate some inverse mappings to enable searches to link from Layout to table
     * objects.
     *
     * TODO: If this has utility elsewhere, move it to TableGeneric and consider caching?
     */
    protected _mapPageContentToTables(): {
        [blockId: string]: TableGeneric<TPage>;
    };
    /**
     * Iterate through the Table objects spanned by this LayoutTable item (usually just 1)
     *
     * Note this is a non-trivial lookup that requires searching through associated WORD blocks, due
     * to the structure of Textract responses. If Textract TABLES analysis was not also enabled in
     * the API, this will return an empty list [].
     *
     * @example
     * for (const field of form.iterFields()) {
     *   console.log(field?.key.text);
     * }
     * @example
     * const fields = [...form.iterFields()];
     */
    iterTables(): Iterable<TableGeneric<TPage>>;
    /**
     * List the Table objects spanned by this LayoutTable item (usually just 1)
     *
     * Note this is a non-trivial lookup that requires searching through associated WORD blocks, due
     * to the structure of Textract responses. If Textract TABLES analysis was not also enabled in
     * the API, this will return an empty list [].
     */
    listTables(): TableGeneric<TPage>[];
    /**
     * The outer semantic HTML representation for a key-value element is a <div class="table">
     *
     * IF Textract TABLES analysis was also run on the document, this will attempt to reconcile the
     * tagged Layout content to extracted `Table`(s) - but this is a non-trivial operation.
     *
     * Since there's no guaranteed 1:1 correspondence between the Layout Table regions and detected
     * Table objects, populate the div content by looping through the plain text (from layout) but
     * inserting the semantic HTML for each whole `<table>` at the first overlapping mention.
     */
    html(): string;
    /**
     * The human-readable `str()` representation for this element does not do Tables reconciliation
     *
     * It just returns the Layout object's `text` with some bookends for clarity.
     */
    str(): string;
}
/**
 * Generic base class for a layout entity describing a paragraph of text
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutText`.
 */
export declare class LayoutTextGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutTextBlock, TPage> implements ILayoutItem<ApiLayoutTextBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutTextBlock, TPage>> {
    /**
     * The semantic HTML representation for a text element is a <p> paragraph tag
     */
    html(): string;
    /**
     * The human-readable string representation for a text element is just the text itself.
     */
    str(): string;
}
/**
 * Generic base class for a layout entity describing a top-level document title
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutTitle`.
 */
export declare class LayoutTitleGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutLineContainerItem<ApiLayoutTitleBlock, TPage> implements ILayoutItem<ApiLayoutTitleBlock, LineGeneric<IBlockManager>, TPage, LayoutItemBaseGeneric<ApiLayoutTitleBlock, TPage>> {
    /**
     * The semantic HTML representation for a top-level title is a <h1> tag
     */
    html(): string;
    str(): string;
}
declare const LayoutListGeneric_base: {
    new (...args: any[]): {
        iterContent(): Iterable<LayoutTextGeneric<IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>>>;
        listContent(): LayoutTextGeneric<IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>>[];
        readonly nContentItems: number;
        get text(): string;
        readonly dict: ApiBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: import("./api-models/base").ApiRelationshipType | import("./api-models/base").ApiRelationshipType[]): string[];
        parentPage: IBlockManager;
    };
} & typeof LayoutItemBaseGeneric;
/**
 * Generic base class for a layout entity describing a bulleted or numbered list
 *
 * If you're consuming this library, you probably just want to use `document.ts/LayoutList`.
 */
export declare class LayoutListGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> extends LayoutListGeneric_base<ApiLayoutListBlock, TPage> implements ILayoutItem<ApiLayoutListBlock, LayoutTextGeneric<IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>>, TPage, LayoutItemBaseGeneric<ApiLayoutListBlock, TPage>> {
    /**
     * Render the list as HTML
     *
     * TODO: Support ordered/numbered lists with <ol>, if we can infer when to use it?
     * TODO: innerHTML option on LayoutText to get rid of the <p> tags?
     */
    html(): string;
    /**
     * Iterate through the text `Line`s in this object
     *
     * @example
     * for (const item of layList.iterTextLines()) {
     *   console.log(item.text);
     * }
     * @example
     * [...layList.iterTextLines()].forEach(
     *   (line) => console.log(line.text)
     * );
     */
    iterTextLines(): Iterable<LineGeneric<TPage>>;
    /**
     * List the text `Line` items in this object
     */
    listTextLines(): Array<LineGeneric<TPage>>;
    /**
     * The human-readable `str()` representation of a layout list is same as the (bulleted) `.text`
     */
    str(): string;
    /**
     * Number of text `Line`s in this object
     */
    get nTextLines(): number;
    /**
     * Text for LayoutList is rendered with '-' bullet points at 2/4-space indentation
     */
    get text(): string;
}
/**
 * TypeScript type collecting all possible TRP parsed objects corresponding to layout elements
 */
export type LayoutItemGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> = LayoutFigureGeneric<TPage> | LayoutFooterGeneric<TPage> | LayoutHeaderGeneric<TPage> | LayoutKeyValueGeneric<TPage> | LayoutListGeneric<TPage> | LayoutPageNumberGeneric<TPage> | LayoutSectionHeaderGeneric<TPage> | LayoutTableGeneric<TPage> | LayoutTextGeneric<TPage> | LayoutTitleGeneric<TPage>;
/**
 * Generic base class for a page-level Layout analysis container
 *
 * If you're consuming this library, you probably just want to use `document.ts/Layout`.
 */
export declare class LayoutGeneric<TPage extends IBlockManager & IWithForm<IBlockManager> & IWithTables<IBlockManager>> implements IRenderable, IWithParentPage<TPage> {
    _items: LayoutItemGeneric<TPage>[];
    _parentPage: TPage;
    constructor(layoutBlocks: ApiLayoutBlock[], parentPage: TPage);
    /**
     * Number of layout elements detected on the page
     */
    get nItems(): number;
    /**
     * Parsed TRP.js page to which this Layout corresponds
     */
    get parentPage(): TPage;
    /**
     * Collects the plain text content of all layout items, connected by \n\n
     */
    get text(): string;
    /**
     * Concatenate the HTML representations of items in the layout
     *
     * Since this class is just a collection and not an API object wrapper, we don't wrap the content
     * HTML in anything: Leave that up to `Page`, `Document`, etc.
     */
    html(): string;
    /**
     * Iterate through the Items in the Layout.
     */
    iterItems(): Iterable<LayoutItemGeneric<TPage>>;
    /**
     * List the Items in the Layout.
     */
    listItems(): LayoutItemGeneric<TPage>[];
    /**
     * The human-readable `str()` representation for a page layout
     *
     * This includes contained items' `str()`s, with bookends for clarity
     */
    str(): string;
}
export {};
