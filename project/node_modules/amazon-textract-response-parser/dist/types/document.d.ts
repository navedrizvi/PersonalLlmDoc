/**
 * TRP classes for standard document/OCR results (e.g. DetectText and AnalyzeDocument)
 */
import { ApiBlockType } from "./api-models/base";
import { ApiBlock, ApiPageBlock } from "./api-models/document";
import { ApiResponsePage, ApiResponsePages, ApiResponseWithContent } from "./api-models/response";
import { ApiBlockWrapper, ApiObjectWrapper, IDocBlocks, IBlockManager, IRenderable, IApiBlockWrapper } from "./base";
import { LineGeneric, SelectionElement, Signature, Word } from "./content";
import { FieldGeneric, FieldKeyGeneric, FieldValueGeneric, FormsCompositeGeneric, FormGeneric, IWithForm } from "./form";
import { BoundingBox, Geometry } from "./geometry";
import { LayoutFigureGeneric, LayoutFooterGeneric, LayoutGeneric, LayoutHeaderGeneric, LayoutItemGeneric, LayoutKeyValueGeneric, LayoutListGeneric, LayoutPageNumberGeneric, LayoutSectionHeaderGeneric, LayoutTableGeneric, LayoutTextGeneric, LayoutTitleGeneric } from "./layout";
import { QueryInstanceCollectionGeneric, QueryInstanceGeneric, QueryResultGeneric } from "./query";
import { CellGeneric, IWithTables, MergedCellGeneric, RowGeneric, TableFooterGeneric, TableGeneric, TableTitleGeneric } from "./table";
export { 
/**
 * @deprecated Planned for private-only: Please let us know if you have a use-case for this?
 */
ApiBlockWrapper, } from "./base";
export { SelectionElement, Word } from "./content";
/**
 * How heuristic reading order methods should react to the presence of Textract Layout results
 *
 * When the `Layout` analysis is enabled in Amazon Textract, additional `LAYOUT_*` blocks are
 * generated using ML to infer the structural layout and reference reading order of the page. This
 * carries additional API charges, but is likely to produce more accurate results than our simple
 * TRP.js heuristics.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 *
 * @experimental
 */
export declare const enum ReadingOrderLayoutMode {
    /**
     * Use Textract Layout results for reading order when present, heuristics otherwise
     */
    Auto = "AUTO",
    /**
     * Use heuristics for reading order, even if Textract Layout results are present
     */
    IgnoreLayout = "IGNORE_LAYOUT",
    /**
     * Use Textract Layout results for reading order, throw an error if they're not available
     */
    RequireLayout = "REQUIRE_LAYOUT"
}
/**
 * @experimental
 */
export interface HeuristicReadingOrderModelParams {
    /**
     * Minimum ratio (0-1) of overlap to count a paragraph within a detected column. Applied relative
     * to the *minimum* of {paragraph width, column width}. Can set close to 1 if your columns are
     * well-defined with little skew and no hanging indents.
     */
    colHOverlapThresh?: number;
    /**
     * Minimum ratio (0-1) of intersection to count a paragraph within a detected column. Applied
     * relative to the *union* of {paragraph, column} horizontal span, and *only* when both the
     * paragraph and column contain multiple lines (since single-line paragraphs may be significantly
     * short). Can set close to 1 if your text is justified, since individual paragraphs in a column
     * should have reliably very similar widths.
     */
    colHMultilineUnionThresh?: number;
    /**
     * Maximum vertical distance, in multiples of line height, for a line to be considered eligible
     * for merging into a paragraph. 1.0 may make a sensible default. May set >1.0 if your text has
     * large spacing between lines within a paragraph, or <1.0 if your paragraphs have little
     * vertical separating space between them.
     */
    paraVDistTol?: number;
    /**
     * Maximum ratio of deviation of this line height from average line height in a paragraph, for a
     * line to be considered eligible for merging into a paragraph. Set close to 0 to encourage text
     * size changes to be represented as paragraph breaks (e.g. close-together heading/subheading).
     */
    paraLineHeightTol?: number;
    /**
     * Optional maximum indentation of a line versus previous, after which the line will be forced
     * into a new paragraph even if vertical distance is small. Set =0 to disable this behavior (for
     * e.g. with center-aligned text or where paragraphs are marked by vertical whitespace), or >0 to
     * specify paragraph indentation in terms of a multiplier on text line-height. Default 0.
     */
    paraIndentThresh?: number;
    /**
     * Whether to use Textract Layout results *instead* of heuristics for improved reading order when
     * available; or always use heuristics; or insist on Layout and throw an error if not present.
     */
    useLayout?: ReadingOrderLayoutMode;
}
/**
 * @experimental
 */
export interface HeaderFooterSegmentModelParams {
    /**
     * Cut-off maximum proportion of the page height that the header/footer must be within. Set close
     * to 0 if main content is known to start very close to the page edge, or higher to allow more
     * space for the header/footer search. Default 0.16 (16% page height).
     * @default 0.16 (16% page height)
     */
    maxMargin?: number;
    /**
     * Minimum vertical spacing between header/footer and main page content, as a proportion of
     * average local text LINE height. The header/footer will break on the first gap bigger than
     * this, working in from the edge of the page towards content. Set close to 0 if the main content
     * is known to start very close, or higher if multiple vertically-separate paragraphs/lines
     * should be captured in the header/footer. Default 0.8 (80% line height).
     * @default 0.8 (80% line height)
     */
    minGap?: number;
}
/**
 * Parsed TRP.js object for a single page in a document analysis / text detection result
 *
 * Wraps an Amazon Textract API `PAGE` Block, with utilities for analysis. You'll usually create
 * this via a `TextractDocument`, rather than directly.
 */
export declare class Page extends ApiBlockWrapper<ApiPageBlock> implements IBlockManager, IRenderable, IWithForm<Page>, IWithTables<Page> {
    _blocks: ApiBlock[];
    _content: Array<LineGeneric<Page> | TableGeneric<Page> | FieldGeneric<Page>>;
    _form: FormGeneric<Page>;
    _geometry: Geometry<ApiPageBlock, Page>;
    _itemsByBlockId: {
        [blockId: string]: LineGeneric<Page> | SelectionElement | Signature | Word | FieldGeneric<Page> | FieldValueGeneric<Page> | LayoutItemGeneric<Page> | QueryInstanceGeneric<Page> | QueryResultGeneric<Page> | TableGeneric<Page> | CellGeneric<Page>;
    };
    _layout: LayoutGeneric<Page>;
    _lines: LineGeneric<Page>[];
    _parentDocument: TextractDocument;
    _queries: QueryInstanceCollectionGeneric<Page>;
    _tables: TableGeneric<Page>[];
    /**
     * Create (parse) a Page object from a PAGE block and the list of other Blocks ocurring on it
     *
     * @param pageBlock The API Block object representing the PAGE itself
     * @param blocks The list of all API Blocks occurring on this Page
     * @param parentDocument The parsed TRP.js TextractDocument object the page belongs to
     */
    constructor(pageBlock: ApiPageBlock, blocks: ApiBlock[], parentDocument: TextractDocument);
    _parse(blocks: ApiBlock[]): void;
    getBlockById(blockId: string): ApiBlock | undefined;
    getItemByBlockId(blockId: string, allowBlockTypes?: ApiBlockType | ApiBlockType[] | null): Page | LineGeneric<Page> | SelectionElement | Signature | Word | FieldGeneric<Page> | FieldValueGeneric<Page> | LayoutItemGeneric<Page> | QueryInstanceGeneric<Page> | QueryResultGeneric<Page> | TableGeneric<Page> | CellGeneric<Page>;
    /**
     * Calculate the most common orientation (in whole degrees) of 'WORD' content in the page.
     *
     * Returns `null` if the page contains no valid word blocks.
     */
    getModalWordOrientationDegrees(): number | null;
    /**
     * List lines in reading order, grouped by pseudo-'paragraph' and contiguous 'column'
     * @returns Nested array of text lines by column, paragraph, line
     * @private
     */
    _getLineClustersByColumn({ colHOverlapThresh, colHMultilineUnionThresh, paraVDistTol, paraLineHeightTol, paraIndentThresh, }?: HeuristicReadingOrderModelParams): LineGeneric<Page>[][][];
    /**
     * List lines in reading order, grouped by 'cluster' (somewhat like a paragraph)
     *
     * By default if Amazon Textract Layout analysis was enabled for the document, this method will
     * use those results to infer separate clusters (e.g. paragraphs, headings) and arrange them in
     * expected reading order. If Layout was not analyzed service-side, this method applies local
     * heuristics to group text together into paragraphs, and then sorts paragraphs into "columns" in
     * reading order. Although parameters are exposed to customize the heuristic model, note that
     * this customization API is experimental and subject to change.
     *
     * Textract's ML-powered Layout functionality should generally work better than local heuristics,
     * but carries extra cost and in edge cases it's difficult for any method to define one "correct"
     * reading order for rich content: So can set the `useLayout` mode to ignore (or force)
     * Layout-based calculation if you need.
     *
     * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     *
     * @returns Nested array of text lines by "paragraph"/element, line
     */
    getLineClustersInReadingOrder({ colHOverlapThresh, colHMultilineUnionThresh, paraVDistTol, paraLineHeightTol, paraIndentThresh, useLayout, }?: HeuristicReadingOrderModelParams): LineGeneric<Page>[][];
    /**
     * Extract all page text in approximate reading order
     *
     * By default if Amazon Textract Layout analysis was enabled for the document, this method will
     * use those results to infer separate clusters (e.g. paragraphs, headings) and arrange them in
     * expected reading order. If Layout was not analyzed service-side, this method applies local
     * heuristics to group text together into paragraphs, and then sorts paragraphs into "columns" in
     * reading order. Although parameters are exposed to customize the heuristic model, note that
     * this customization API is experimental and subject to change.
     *
     * Textract's ML-powered Layout functionality should generally work better than local heuristics,
     * but carries extra cost and in edge cases it's difficult for any method to define one "correct"
     * reading order for rich content: So can set the `useLayout` mode to ignore (or force)
     * Layout-based calculation if you need.
     *
     * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     *
     * @returns Nested array of text lines by "paragraph"/element, line
     */
    getTextInReadingOrder({ colHOverlapThresh, colHMultilineUnionThresh, paraVDistTol, paraLineHeightTol, paraIndentThresh, useLayout, }?: HeuristicReadingOrderModelParams): string;
    /**
     * Split lines of text into vertically contiguous groups, and describe the gaps between groups
     *
     * Useful for finding vertical cut-offs by looking for largest vertical gaps in a region. Note
     * that by 'contiguous' here we mean literally overlapping: small gaps are not filtered out, and
     * the iterative splitting process may cause the output order to be different from either the
     * human reading order or the Amazon Textract output order.
     *
     * @param {number} focusTop Top coordinate of the search area on the page. All lines above the
     *      search area will be compressed into one group regardless of separation.
     * @param {number} focusHeight Height of the search area on the page. All lines below the search
     *      area will be compressed into one group regardless of separation.
     * @param {Line[]} [lines] Optional array of Line objects to group. By default, the full list of
     *      lines on the page will be analyzed.
     * @returns Object with props 'lines' (the list of Lines in each group) and 'vGaps' (a
     *      list of BoundingBox objects describing the gaps between the groups). Note that this means
     *      `lines.length == vGaps.length + 1`.
     */
    _groupLinesByVerticalGaps(focusTop: number, focusHeight: number, lines?: LineGeneric<Page>[]): {
        vGaps: BoundingBox<unknown, ApiObjectWrapper<unknown>>[];
        lines: LineGeneric<Page>[][];
    };
    /**
     * Identify (via heuristics) the list of Lines likely to be page header or page footer.
     *
     * Output lines are not guaranteed to be sorted either in reading order or strictly in the
     * default Amazon Textract output order.
     *
     * @param {boolean} isHeader Set true for header, or false for footer.
     * @param {HeaderFooterSegmentModelParams} [config] (Experimental) heuristic configurations.
     * @param {Line[]} [fromLines] Optional array of Line objects to group. By default, the full list
     *      of lines on the page will be analyzed.
     * @returns {Line[]} Array of Lines in the relevant section.
     */
    _getHeaderOrFooterLines(isHeader: boolean, { maxMargin, minGap }?: HeaderFooterSegmentModelParams, fromLines?: LineGeneric<Page>[]): LineGeneric<Page>[];
    /**
     * Identify (via heuristics) the list of Lines likely to be page footer.
     *
     * Output lines are not guaranteed to be sorted either in reading order or strictly in the
     * default Amazon Textract output order. See also getLinesByLayoutArea() for this.
     *
     * TODO: Consider updating for Textract Layout where available
     *
     * @param {HeaderFooterSegmentModelParams} [config] (Experimental) heuristic configurations.
     * @param {Line[]} [fromLines] Optional array of Line objects to group. By default, the full list
     *      of lines on the page will be analyzed.
     * @returns {Line[]} Array of Lines in the relevant section.
     */
    getFooterLines(config?: HeaderFooterSegmentModelParams, fromLines?: LineGeneric<Page>[]): LineGeneric<Page>[];
    /**
     * Identify (via heuristics) the list of Lines likely to be page header.
     *
     * Output lines are not guaranteed to be sorted either in reading order or strictly in the
     * default Amazon Textract output order. See also getLinesByLayoutArea() for this.
     *
     * TODO: Consider updating for Textract Layout where available
     *
     * @param {HeaderFooterSegmentModelParams} [config] (Experimental) heuristic configurations.
     * @param {Line[]} [fromLines] Optional array of Line objects to group. By default, the full list
     *      of lines on the page will be analyzed.
     * @returns {Line[]} Array of Lines in the relevant section.
     */
    getHeaderLines(config?: HeaderFooterSegmentModelParams, fromLines?: LineGeneric<Page>[]): LineGeneric<Page>[];
    /**
     * Segment page text into header, content, and footer - optionally in (approximate) reading order
     *
     * TODO: Consider updating for Textract Layout where available
     *
     * @param {boolean|HeuristicReadingOrderModelParams} [inReadingOrder=false] Set true to sort text
     *      in reading order, or leave false (the default) to use the standard Textract ouput order
     *      instead. To customize the (experimental) parameters of the reading order model, pass in a
     *      configuration object instead of true.
     * @param {HeaderFooterSegmentModelParams} [headerConfig] (Experimental) heuristic configurations
     *      for header extraction.
     * @param {HeaderFooterSegmentModelParams} [footerConfig] (Experimental) heuristic configurations
     *      for footer extraction.
     * @returns Object with .header, .content, .footer properties: Each of type Line[].
     */
    getLinesByLayoutArea(inReadingOrder?: boolean | HeuristicReadingOrderModelParams, headerConfig?: HeaderFooterSegmentModelParams, footerConfig?: HeaderFooterSegmentModelParams): {
        header: LineGeneric<Page>[];
        content: LineGeneric<Page>[];
        footer: LineGeneric<Page>[];
    };
    /**
     * Iterate through the text lines on the page in raw Textract order
     *
     * For reading order, see `.layout` or `.getLineClustersInReadingOrder` instead.
     *
     * @example
     * for (const line of page.iterLines()) {
     *   console.log(line.text);
     * }
     */
    iterLines(): Iterable<LineGeneric<Page>>;
    /**
     * Iterate through any signatures detected on the page
     *
     * If this Textract feature was not enabled, the iterator will be empty
     *
     * @example
     * for (const line of page.iterLines()) {
     *   console.log(line.text);
     * }
     */
    iterSignatures(): Iterable<Signature>;
    /**
     * Iterate through the tables on the page
     *
     * If TABLES analysis was not enabled, the iterable will be empty.
     *
     * @example
     * for (const table of page.iterTables()) {
     *   console.log(table.str());
     * }
     * @example
     * const tables = [...page.iterTables()];
     */
    iterTables(): Iterable<TableGeneric<Page>>;
    /**
     * Fetch a particular parsed `Line` of text on the page by its index in the Textract result
     *
     * For reading order, see `.layout` or `.getLineClustersInReadingOrder` instead.
     *
     * @param ix 0-based index of the parsed Line to fetch
     * @returns The item at position `ix` in this page's list of text lines (in raw Textract order)
     * @throws If `ix` is less than 0, or gte than the number of text lines on the page
     */
    lineAtIndex(ix: number): LineGeneric<Page>;
    /**
     * Fetch a snapshot of the list of all API `Block` items owned by this PAGE
     *
     * @returns (A shallow copy of) the list of raw `Block` objects
     */
    listBlocks(): ApiBlock[];
    /**
     * Fetch a snapshot of the list of all text lines on the page, in raw Textract order
     *
     * For reading order, see `.layout` or `.getLineClustersInReadingOrder` instead.
     *
     * @returns (A shallow copy of) the list of parsed `Line`s present on this page
     */
    listLines(): LineGeneric<Page>[];
    /**
     * Fetch a snapshot list of any signatures detected on the page
     *
     * If this Textract feature was not enabled, the iterator will be empty
     *
     * @returns (A shallow/snapshot copy of) the list of parsed `Signature`s present on this page
     */
    listSignatures(): Signature[];
    /**
     * Fetch a snapshot of the list of Tables present on this page
     *
     * If TABLES analysis was not enabled, will return empty list `[]`.
     *
     * @returns (A shallow copy of) the list of parsed `Table`s present on this page
     */
    listTables(): TableGeneric<Page>[];
    registerParsedItem(blockId: string, item: LineGeneric<Page> | SelectionElement | Word | FieldGeneric<Page> | FieldValueGeneric<Page> | LayoutItemGeneric<Page> | QueryInstanceGeneric<Page> | QueryResultGeneric<Page> | TableGeneric<Page> | CellGeneric<Page>): void;
    /**
     * Fetch a particular parsed `Table` on the page by its index in the Textract result
     *
     * (See also `.iterTables()`, `.listTables()`)
     *
     * @param ix 0-based index of the Table to fetch
     * @returns The item at position `ix` in this page's list of tables
     * @throws If `ix` is less than 0, or gte than the number of tables on the page
     */
    tableAtIndex(ix: number): TableGeneric<Page>;
    /**
     * The Textract Forms analysis result container for this page (even if the feature was disabled)
     *
     * For details see: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
     */
    get form(): FormGeneric<Page>;
    /**
     * Shape & position of the page relative to the input image.
     *
     * This is typically the whole [0,0]-[1,1] box (esp for digital documents e.g. PDFs), or
     * something close to it (for photographs of receipts, etc).
     */
    get geometry(): Geometry<ApiPageBlock, Page>;
    /**
     * Whether this page includes results from a Textract Layout analysis
     *
     * For details see: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     */
    get hasLayout(): boolean;
    /**
     * The Textract Layout analysis result container for this page (even if the feature was disabled)
     *
     * For details see: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     */
    get layout(): LayoutGeneric<Page>;
    /**
     * Number of text LINE blocks present in the page
     */
    get nLines(): number;
    /**
     * Number of SIGNATURE blocks detected in the page (0 if Signatures analysis was not enabled)
     */
    get nSignatures(): number;
    /**
     * Number of TABLEs present in the page (0 if Tables analysis was not enabled)
     */
    get nTables(): number;
    /**
     * 1-based page number of this Page in the parent TextractDocument
     */
    get pageNumber(): number;
    /**
     * Parsed document object to which this individual page belongs
     */
    get parentDocument(): TextractDocument;
    /**
     * The Textract Queries analysis result container for this page (even if the feature was disabled)
     *
     * For details see: https://docs.aws.amazon.com/textract/latest/dg/queryresponse.html
     */
    get queries(): QueryInstanceCollectionGeneric<Page>;
    /**
     * Property to simply extract all text on the page
     *
     * This is calculated by concatenating the text of all the page's LINE Blocks.
     */
    get text(): string;
    /**
     * Return a best-effort semantic HTML representation of the page and its content
     *
     * This is useful for ingesting the document into tools like search engines or Generative Large
     * Language Models (LLMs) that might be capable of understanding semantic structure such as
     * paragraphs or headings, but cannot consume fully multi-modal (image/text coordinate) data.
     *
     * If the Textract LAYOUT feature was enabled, this function uses its results to assemble and
     * sequence paragraphs, headings, and other features.
     *
     * TODO: Support more basic .html() on Textract results for which LAYOUT analysis was not enabled
     *
     * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     *
     * @throws If Textract Layout analysis was not enabled in the API request.
     */
    html(): string;
    str(): string;
}
/**
 * Parsed TRP object for a line of text on the page
 *
 * Wraps an Amazon Textract `LINE` Block in the underlying API response. You'll usually create
 * this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-lines-words.html
 */
export declare class Line extends LineGeneric<Page> {
}
/**
 * Parsed TRP object for a key-value field in form analysis data
 *
 * You'll usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
 */
export declare class Field extends FieldGeneric<Page> {
}
/**
 * Parsed TRP object for the key/label of a key-value field pair in form analysis data
 *
 * Wraps an Amazon Textract `KEY_VALUE_SET` (or `KEY`) Block in the underlying API response. You'll
 * usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
 */
export declare class FieldKey extends FieldKeyGeneric<Page> {
}
/**
 * Parsed TRP object for the value/data of a key-value field pair in form analysis data
 *
 * Wraps an Amazon Textract `KEY_VALUE_SET` (or `VALUE`) Block in the underlying API response.
 * You'll usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
 */
export declare class FieldValue extends FieldValueGeneric<Page> {
}
/**
 * Parsed TRP object wrapping all the key-value form data for one page of a document
 *
 * You'll usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
 */
export declare class Form extends FormGeneric<Page> {
}
/**
 * Parsed TRP object for a diagram / image / figure on a page, detected by document layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_FIGURE` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutFigure extends LayoutFigureGeneric<Page> {
}
/**
 * Parsed TRP object for an element of page footer content, detected by document layout analysis
 *
 * Note this excludes page numbers (see `LayoutPageNumber`). Wraps an Amazon Textract
 * `LAYOUT_FOOTER` Block in the underlying API response. You'll usually create this via a
 * `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutFooter extends LayoutFooterGeneric<Page> {
}
/**
 * Parsed TRP object for an element of page header content, detected by document layout analysis
 *
 * Note this excludes page numbers (see `LayoutPageNumber`). Wraps an Amazon Textract
 * `LAYOUT_HEADER` Block in the underlying API response. You'll usually create this via a
 * `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutHeader extends LayoutHeaderGeneric<Page> {
}
/**
 * Parsed TRP object for an area of key-value (form data) content, detected by layout analysis
 *
 * Note this typically includes multiple `Field` objects (if you have forms data analysis enabled).
 * Wraps an Amazon Textract `LAYOUT_KEY_VALUE` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutKeyValue extends LayoutKeyValueGeneric<Page> {
}
/**
 * Parsed TRP object for a page number annotation, detected by document layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_PAGE_NUMBER` Block in the underlying API response. You'll
 * usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutPageNumber extends LayoutPageNumberGeneric<Page> {
}
/**
 * Parsed TRP object for a section heading / title, detected by document layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_SECTION_HEADER` Block in the underlying API response. You'll
 * usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutSectionHeader extends LayoutSectionHeaderGeneric<Page> {
}
/**
 * Parsed TRP object for a table, detected by document layout analysis
 *
 * Note this can link through to, but may not correspond 1:1 with, structured table data extracted
 * by the Tables analysis. Wraps an Amazon Textract `LAYOUT_TABLE` Block in the underlying API
 * response. You'll usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutTable extends LayoutTableGeneric<Page> {
}
/**
 * Parsed TRP object for a paragraph / independent element of text, detected by layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_TEXT` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutText extends LayoutTextGeneric<Page> {
}
/**
 * Parsed TRP object for an overall document title, detected by document layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_TITLE` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutTitle extends LayoutTitleGeneric<Page> {
}
/**
 * Parsed TRP object for a bulleted or numbered list, detected by document layout analysis
 *
 * Wraps an Amazon Textract `LAYOUT_LIST` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class LayoutList extends LayoutListGeneric<Page> {
}
/**
 * Parsed TRP object for the overall layout of a page, detected by document layout analysis
 *
 * Can be used to iterate through content like headings, paragraphs, headers and footers, in
 * implied reading order (even for multi-column documents). You'll usually create this via a
 * `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
 */
export declare class Layout extends LayoutGeneric<Page> {
}
/**
 * Parsed TRP object for one page's instance of a submitted Amazon Textract Query
 *
 * Wraps an Amazon Textract `QUERY` Block in the underlying API response. You'll usually create
 * this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/queryresponse.html
 */
export declare class QueryInstance extends QueryInstanceGeneric<Page> {
}
/**
 * Parsed TRP object wrapping all the Textract Queries results for one page in a document
 *
 * You'll usually create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/queryresponse.html
 */
export declare class QueryInstanceCollection extends QueryInstanceCollectionGeneric<Page> {
}
/**
 * Parsed TRP object for one detected result for a submitted Amazon Textract Query
 *
 * Wraps an Amazon Textract `QUERY_RESULT` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/queryresponse.html
 */
export declare class QueryResult extends QueryResultGeneric<Page> {
}
/**
 * Parsed TRP object for a (sub-)cell of a table, before considering any merged cells
 *
 * Wraps an Amazon Textract `CELL` Block in the underlying API response. You'll usually create this
 * via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class Cell extends CellGeneric<Page> {
}
/**
 * Parsed TRP object for a merged cell in a table
 *
 * Wraps an Amazon Textract `MERGED_CELL` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class MergedCell extends MergedCellGeneric<Page> {
}
/**
 * Parsed TRP object for one row in a table
 *
 * `Row`s don't directly wrap any one object in Amazon Textract API results, but are a collection
 * used to help iterate through table contents. You'll usually create this via a
 * `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class Row extends RowGeneric<Page> {
}
/**
 * Parsed TRP object for a table on a page, detected by document tables analysis
 *
 * Wraps an Amazon Textract `TABLE` Block in the underlying API response. You'll usually create
 * this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class Table extends TableGeneric<Page> {
}
/**
 * Parsed TRP object for a trailing/footer caption of a table
 *
 * Wraps an Amazon Textract `TABLE_FOOTER` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class TableFooter extends TableFooterGeneric<Page> {
}
/**
 * Parsed TRP object for a leading/header caption of a table
 *
 * Wraps an Amazon Textract `TABLE_TITLE` Block in the underlying API response. You'll usually
 * create this via a `TextractDocument`, rather than directly.
 *
 * See: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-tables.html
 */
export declare class TableTitle extends TableTitleGeneric<Page> {
}
/**
 * Main TRP class to parse and analyze Amazon Textract document analysis & text detection results
 */
export declare class TextractDocument extends ApiObjectWrapper<ApiResponsePage & ApiResponseWithContent> implements IDocBlocks, IRenderable {
    _blockMap: {
        [blockId: string]: ApiBlock;
    };
    _form: FormsCompositeGeneric<Page, TextractDocument>;
    _pages: Page[];
    /**
     * Create (parse) a TextractDocument from Amazon Textract API response JSON(s)
     *
     * @param textractResults A (parsed) Textract response JSON, or an array of multiple from the same job
     */
    constructor(textractResults: ApiResponsePage | ApiResponsePages);
    _parse(): void;
    static _consolidateMultipleResponses(textractResultArray: ApiResponsePages): ApiResponsePage & ApiResponseWithContent;
    /**
     * The Textract Forms analysis result container for all K-Vs across the document
     *
     * This object is still created (but will be empty) if the Textract FORMS analysis was disabled
     *
     * For details see: https://docs.aws.amazon.com/textract/latest/dg/how-it-works-kvp.html
     */
    get form(): FormsComposite;
    /**
     * The number of pages present in the document
     */
    get nPages(): number;
    /**
     * Property to simply extract the document content as flat text
     *
     * Page contents are separated by 4 newlines
     */
    get text(): string;
    getBlockById(blockId: string): ApiBlock | undefined;
    /**
     * Return a parsed TRP.js object corresponding to an API Block
     *
     * At the document level, this works by querying each `Page` in turn
     *
     * @param blockId Unique ID of the API Block for which a parsed object should be fetched
     * @param allowBlockTypes Optional restriction on acceptable ApiBlockType(s) to return
     * @throws If no parsed object exists for the block ID, or it doesn't match `allowBlockTypes`
     */
    getItemByBlockId(blockId: string, allowBlockTypes?: ApiBlockType | ApiBlockType[] | null): IApiBlockWrapper<ApiBlock>;
    /**
     * Iterate through the pages of the document
     * @example
     * for (const page of doc.iterPages()) {
     *   console.log(page.str());
     * }
     * @example
     * const pages = [...doc.iterPages()];
     */
    iterPages(): Iterable<Page>;
    /**
     * Fetch a snapshot of the list of all API `Block` items owned by this PAGE
     *
     * @returns (A shallow copy of) the list of raw `Block` objects
     */
    listBlocks(): ApiBlock[];
    /**
     * Fetch a snapshot of the list of parsed `Page`s in this document object
     *
     * @returns (A shallow copy of) the list of parsed `Page` objects
     */
    listPages(): Page[];
    /**
     * Fetch a parsed `Page` of the document by 1-based page number
     * @param pageNum 1-based index of the target page to fetch
     * @throws If `pageNum` is less than 1, or greater than or equal to `doc.nPages``
     */
    pageNumber(pageNum: number): Page;
    /**
     * Return a best-effort semantic HTML representation of the document
     *
     * This is useful for ingesting the document into tools like search engines or Generative Large
     * Language Models (LLMs) that might be capable of understanding semantic structure such as
     * paragraphs or headings, but cannot consume fully multi-modal (image/text coordinate) data.
     *
     * As per `Page.html()`, this currently depends on the Textract LAYOUT feature being enabled in
     * the underlying API request.
     *
     * TODO: Support more basic .html() on Textract results for which LAYOUT analysis was not enabled
     *
     * See: https://docs.aws.amazon.com/textract/latest/dg/layoutresponse.html
     *
     * @throws If Textract Layout analysis was not enabled in the API request.
     */
    html(): string;
    str(): string;
}
export declare class FormsComposite extends FormsCompositeGeneric<Page, TextractDocument> {
}
