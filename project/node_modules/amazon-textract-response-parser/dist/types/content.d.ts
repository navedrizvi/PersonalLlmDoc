/**
 * TRP classes for (generic document) low-level content objects
 */
import { ApiBlockType } from "./api-models/base";
import { ApiLineBlock, ApiSelectionElementBlock, ApiSelectionStatus, ApiSignatureBlock, ApiTextType, ApiWordBlock } from "./api-models/content";
import { ApiBlock } from "./api-models/document";
import { ApiBlockWrapper, Constructor, IApiBlockWrapper, IBlockManager, IRenderable, IWithParentPage, IWithText, PageHostedApiBlockWrapper } from "./base";
import { Geometry, IWithGeometry } from "./geometry";
/**
 * TRP.js parsed object for an individual word of text
 *
 * Wraps an Amazon Textract `WORD` block in the underlying API response.
 */
export declare class Word extends ApiBlockWrapper<ApiWordBlock> implements IRenderable, IWithGeometry<ApiWordBlock, Word> {
    _geometry: Geometry<ApiWordBlock, Word>;
    constructor(block: ApiWordBlock);
    /**
     * 0-100 based confidence of the OCR model in extracting the text of this word
     */
    get confidence(): number;
    set confidence(newVal: number);
    /**
     * Position of the word on the input image / page
     */
    get geometry(): Geometry<ApiWordBlock, Word>;
    /**
     * Text extracted by the OCR model
     */
    get text(): string;
    /**
     * Whether the text appears hand-written or computer-generated
     */
    get textType(): ApiTextType;
    set textType(newVal: ApiTextType);
    /**
     * The semantic `html()` representation of a `Word` is just the (HTML-escaped) text
     */
    html(): string;
    /**
     * The basic human-readable `str()` representation of a `Word` is just the `.text`
     */
    str(): string;
}
/**
 * Interface for objects that have child items representing actual "content"
 *
 * Typically used for containers of low-level content items like `Word`s and `SelectionElement`s.
 * In some cases (like Layout), higher-level containers (of items like `LINE` may use the same
 * interface.
 *
 * For objects guaranteed to contain only `Word`s (no `SelectionElement`s), prefer `IWithWords`
 * instead.
 */
export interface IWithContent<TContent extends IApiBlockWrapper<ApiBlock> & IRenderable> extends IWithText {
    /**
     * Number of content items in this object
     */
    get nContentItems(): number;
    /**
     * Iterate through the Content items in this object
     * @example
     * for (const item of cell.iterContent()) {
     *   console.log(item.text);
     * }
     * @example
     * [...cell.iterContent()].forEach(
     *   (item) => console.log(item.text)
     * );
     */
    iterContent(): Iterable<TContent>;
    /**
     * List the Content items in this object
     */
    listContent(): Array<TContent>;
}
/**
 * Configuration options for WithContent mixin (see `buildWithContent`)
 */
export interface IWithContentMixinOptions {
    /**
     * What types of direct Child Block to consider as "content"
     *
     * Defaults to [SELECTION_ELEMENT, SIGNATURE, WORD] as per `buildWithContent`
     */
    contentTypes?: ApiBlockType[];
    /**
     * Set `true` to throw an error if content iteration finds a child not in `contentTypes`
     */
    strict?: boolean;
}
/**
 * Mixin factory for elements that have child Content (such as `Word`s and/or `SelectionElement`s)
 *
 * While it's possible to apply a TS mixin to a generic base class (with expressions like
 * `extends MyMixin(BaseClass)<TBaseArgs...>`), mixins cannot alter the base class' constructor
 * signature so they can't introduce additional type arguments (generic aspects) of their own. This
 * double-call mixin factory pattern provides a workaround *only* for cases where we're able to
 * specify the mixin type arguments at the point it's applied: Enabling a somewhat generic
 * definition of "content" that consumer classes can dictate.
 *
 * For objects guaranteed to contain only `Word` items, prefer `WithWords` instead.
 *
 * See: https://stackoverflow.com/a/48492205/13352657
 *
 * @param contentBlockTypes API block types to be included when listing child "Content". Set `[]`
 *    to disable this filter and preserve all items
 */
export declare function buildWithContent<TContent extends IApiBlockWrapper<ApiBlock> & IRenderable>({ contentTypes, strict, }?: IWithContentMixinOptions): <TBlock extends ApiBlock, TPage extends IBlockManager, T extends Constructor<IApiBlockWrapper<TBlock> & IWithParentPage<TPage>>>(SuperClass: T) => {
    new (...args: any[]): {
        iterContent(): Iterable<TContent>;
        listContent(): Array<TContent>;
        readonly nContentItems: number;
        /**
         * A default text representation getter that concatenates child content separated by spaces
         *
         * Objects (like `Line`) that define their own representation of the overall text or need to
         * join content with something other than a space (like a newline) should override this.
         */
        get text(): string;
        readonly dict: TBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: import("./api-models/base").ApiRelationshipType | import("./api-models/base").ApiRelationshipType[]): string[];
        parentPage: TPage;
    };
} & T;
/**
 * Interface for objects that have child `Word`s (such as LINEs of text)
 *
 * For objects that might contain `SelectionElement`s as well (such as table cells), use
 * `IWithContent` instead.
 */
export interface IWithWords extends IWithText {
    /**
     * Number of text Words in this object
     */
    get nWords(): number;
    /**
     * Iterate through the text `Word` items in this object
     * @example
     * for (const word of line.iterWords()) {
     *   console.log(word.text);
     * }
     * @example
     * [...line.iterWords()].forEach(
     *   (word) => console.log(word.text)
     * );
     */
    iterWords(): Iterable<Word>;
    /**
     * List the text `Word`s in this object
     */
    listWords(): Word[];
    /**
     * Fetch a particular text `Word` in this object by index from 0 to `.nWords - 1`
     * @param ix 0-based index in the word list
     * @throws if the index is out of bounds
     */
    wordAtIndex(ix: number): Word;
}
/**
 * Mixin for page-hosted API block wrappers with CHILD relations to WORD objects
 *
 * Adds dynamic functionality to list and traverse the Word objects contained in the content, and a
 * basic implementation for getting the overall `.text`.
 */
export declare function WithWords<TBlock extends ApiBlock, TPage extends IBlockManager, T extends Constructor<IApiBlockWrapper<TBlock> & IWithParentPage<TPage>>>(SuperClass: T): {
    new (...args: any[]): {
        iterWords(): Iterable<Word>;
        listWords(): Word[];
        readonly nWords: number;
        /**
         * A default text representation getter that concatenates child `Word`s separated by spaces
         *
         * Objects (like `Line`) that define their own representation of the overall text or need to
         * join words with something other than a space (like a newline) should override this.
         */
        get text(): string;
        wordAtIndex(ix: number): Word;
        readonly dict: TBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: import("./api-models/base").ApiRelationshipType | import("./api-models/base").ApiRelationshipType[]): string[];
        parentPage: TPage;
    };
} & T;
declare const LineGeneric_base: {
    new (...args: any[]): {
        iterWords(): Iterable<Word>;
        listWords(): Word[];
        readonly nWords: number;
        /**
         * A default text representation getter that concatenates child `Word`s separated by spaces
         *
         * Objects (like `Line`) that define their own representation of the overall text or need to
         * join words with something other than a space (like a newline) should override this.
         */
        get text(): string;
        wordAtIndex(ix: number): Word;
        readonly dict: ApiBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: import("./api-models/base").ApiRelationshipType | import("./api-models/base").ApiRelationshipType[]): string[];
        parentPage: IBlockManager;
    };
} & typeof PageHostedApiBlockWrapper;
/**
 * Generic base class for a Line, as the parent Page is not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/Line`.
 */
export declare class LineGeneric<TPage extends IBlockManager> extends LineGeneric_base<ApiLineBlock, TPage> implements IRenderable, IWithGeometry<ApiLineBlock, LineGeneric<TPage>> {
    _geometry: Geometry<ApiLineBlock, LineGeneric<TPage>>;
    constructor(block: ApiLineBlock, parentPage: TPage);
    get confidence(): number;
    set confidence(newVal: number);
    /**
     * Position of the text line on the input image / page
     */
    get geometry(): Geometry<ApiLineBlock, LineGeneric<TPage>>;
    /**
     * Text content of the LINE
     *
     * This uses the pre-calculated `.Text` property on the Block, rather than concatenating WORDs
     */
    get text(): string;
    /**
     * The semantic `html()` representation of a `Line` is just the (HTML-escaped) text
     */
    html(): string;
    str(): string;
}
/**
 * TRP.js parsed object for a selection element, such as a checkbox or radio selector
 *
 * Wraps an Amazon Textract `SELECTION_ELEMENT` block in the underlying API response.
 */
export declare class SelectionElement extends ApiBlockWrapper<ApiSelectionElementBlock> implements IRenderable, IWithGeometry<ApiSelectionElementBlock, SelectionElement> {
    _geometry: Geometry<ApiSelectionElementBlock, SelectionElement>;
    constructor(block: ApiSelectionElementBlock);
    /**
     * 0-100 based confidence of the model detecting this selection element and its status
     */
    get confidence(): number;
    set confidence(newVal: number);
    /**
     * Position of the selection element on the input image / page
     */
    get geometry(): Geometry<ApiSelectionElementBlock, SelectionElement>;
    /**
     * Whether the element is selected/ticked/checked/etc, or not
     */
    get selectionStatus(): ApiSelectionStatus;
    set selectionStatus(newVal: ApiSelectionStatus);
    /**
     * The semantic `html()` representation of a `SelectionElement` uses an `<input>` element
     *
     * We render a checkbox, but `disable` it to prevent accidental edits when viewing reports
     */
    html(): string;
    /**
     * The human-readable `str()` representation of a sel. element is just the `.selectionStatus`
     */
    str(): string;
    /**
     * The "text content" of a sel. element is just the `.selectionStatus`
     */
    get text(): string;
}
/**
 * TRP.js parsed object for a detected signature
 *
 * Wraps an Amazon Textract `SIGNATURE` block in the underlying API response.
 */
export declare class Signature extends ApiBlockWrapper<ApiSignatureBlock> implements IRenderable, IWithGeometry<ApiSignatureBlock, Signature> {
    _geometry: Geometry<ApiSignatureBlock, Signature>;
    constructor(block: ApiSignatureBlock);
    /**
     * 0-100 based confidence of the model detecting this selection element and its status
     */
    get confidence(): number;
    set confidence(newVal: number);
    /**
     * Position of the selection element on the input image / page
     */
    get geometry(): Geometry<ApiSignatureBlock, Signature>;
    /**
     * The semantic `html()` representation of a `SelectionElement` uses an `<input>` element
     *
     * We render a checkbox, but `disable` it to prevent accidental edits when viewirg reports
     */
    html(): string;
    /**
     * The human-readable `str()` representation of a signature is a placeholder
     *
     * Looks like:
     *
     * /-------------\
     * | [SIGNATURE] |
     * \-------------/
     */
    str(): string;
    /**
     * The "text content" of a signature element is empty
     */
    get text(): "";
}
export {};
