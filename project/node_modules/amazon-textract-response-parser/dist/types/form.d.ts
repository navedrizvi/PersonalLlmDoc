/**
 * TRP classes for (generic document) key-value form objects
 */
import { ApiBlockType, ApiRelationshipType } from "./api-models/base";
import { ApiKeyBlock, ApiKeyValueSetBlock, ApiValueBlock } from "./api-models/form";
import { AggregationMethod, IApiBlockWrapper, IBlockManager, IDocBlocks, IRenderable, PageHostedApiBlockWrapper } from "./base";
import { IWithContent, SelectionElement, Signature, Word } from "./content";
import { Geometry, IWithGeometry } from "./geometry";
declare const FieldKeyGeneric_base: {
    new (...args: any[]): {
        iterWords(): Iterable<Word>;
        listWords(): Word[];
        readonly nWords: number;
        get text(): string;
        wordAtIndex(ix: number): Word;
        readonly dict: import("./api-models").ApiBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: ApiRelationshipType | ApiRelationshipType[]): string[];
        parentPage: IBlockManager;
    };
} & typeof PageHostedApiBlockWrapper;
/**
 * Generic base class for a FieldKey, as the parent Page is not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/FieldKey`.
 */
export declare class FieldKeyGeneric<TPage extends IBlockManager> extends FieldKeyGeneric_base<ApiKeyBlock | ApiKeyValueSetBlock, TPage> implements IRenderable, IWithGeometry<ApiKeyBlock | ApiKeyValueSetBlock, FieldKeyGeneric<TPage>> {
    _geometry: Geometry<ApiKeyBlock | ApiKeyValueSetBlock, FieldKeyGeneric<TPage>>;
    _parentField: FieldGeneric<TPage>;
    constructor(block: ApiKeyBlock | ApiKeyValueSetBlock, parentField: FieldGeneric<TPage>);
    get geometry(): Geometry<ApiKeyBlock | ApiKeyValueSetBlock, FieldKeyGeneric<TPage>>;
    get parentField(): FieldGeneric<TPage>;
    /**
     * Structural (not text) confidence score of the key/value pair detection
     *
     * This score reflects the confidence of the model detecting the key-value relation. For the text
     * OCR confidence, see the `.getOcrConfidence()` method instead.
     */
    get confidence(): number;
    /**
     * Aggregate OCR confidence score of the text in this field key
     *
     * This score reflects the aggregated OCR confidence of the text detected in the field key. For
     * the model's confidence on the key/value relation itself, see `.confidence`.
     *
     * @param {AggregationMethod} aggMethod How to combine individual word OCR confidences together
     * @returns Aggregated confidence, or null if this field key has no content/text
     */
    getOcrConfidence(aggMethod?: AggregationMethod): number | null;
    /**
     * The semantic `html()` representation of a field key is just the (HTML-escaped) text
     */
    html(): string;
    /**
     * The `str()` representation of a field key is just the contained text
     */
    str(): string;
}
declare const FieldValueGeneric_base: {
    new (...args: any[]): {
        iterContent(): Iterable<Word | SelectionElement | Signature>;
        listContent(): (Word | SelectionElement | Signature)[];
        readonly nContentItems: number;
        get text(): string;
        readonly dict: import("./api-models").ApiBlock;
        readonly id: string;
        readonly blockType: ApiBlockType;
        readonly childBlockIds: string[];
        relatedBlockIdsByRelType(relType: ApiRelationshipType | ApiRelationshipType[]): string[];
        parentPage: IBlockManager;
    };
} & typeof PageHostedApiBlockWrapper;
/**
 * Generic base class for a FieldValue, as the parent Page is not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/FieldValue`.
 */
export declare class FieldValueGeneric<TPage extends IBlockManager> extends FieldValueGeneric_base<ApiKeyValueSetBlock | ApiValueBlock, TPage> implements IRenderable, IWithContent<SelectionElement | Signature | Word>, IWithGeometry<ApiKeyValueSetBlock | ApiValueBlock, FieldValueGeneric<TPage>> {
    _geometry: Geometry<ApiKeyValueSetBlock | ApiValueBlock, FieldValueGeneric<TPage>>;
    _parentField: FieldGeneric<TPage>;
    constructor(valueBlock: ApiKeyValueSetBlock | ApiValueBlock, parentField: FieldGeneric<TPage>);
    /**
     * Structural (not text) confidence score of the key/value pair detection
     *
     * This score reflects the confidence of the model detecting the key-value relation. For the text
     * OCR confidence, see the `.getOcrConfidence()` method instead.
     */
    get confidence(): number;
    get geometry(): Geometry<ApiKeyValueSetBlock | ApiValueBlock, FieldValueGeneric<TPage>>;
    get parentField(): FieldGeneric<TPage>;
    /**
     * Aggregate OCR confidence score of the text in this field value
     *
     * This score reflects the aggregated OCR confidence of the text detected in the field value. For
     * the model's confidence on the key/value relation itself, see `.confidence`.
     *
     * @param {AggregationMethod} aggMethod How to combine individual word OCR confidences together
     * @returns Aggregated confidence, or null if this field value has no content/text
     */
    getOcrConfidence(aggMethod?: AggregationMethod): number | null;
    /**
     * The semantic `html()` representation of a field value is just the (HTML-escaped) text
     */
    html(): string;
    /**
     * The `str()` representation of a field value is just the contained text
     */
    str(): string;
}
/**
 * Generic base class for a Field, as the parent Page is not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/Field`.
 *
 * TODO: We should probably do away with FieldKeyGeneric and just use this class?
 * Then it could directly wrap underlying objects
 */
export declare class FieldGeneric<TPage extends IBlockManager> implements IApiBlockWrapper<ApiKeyBlock | ApiKeyValueSetBlock>, IRenderable {
    _key: FieldKeyGeneric<TPage>;
    _parentForm: FormGeneric<TPage>;
    _value: FieldValueGeneric<TPage> | null;
    constructor(keyBlock: ApiKeyBlock | ApiKeyValueSetBlock, parentForm: FormGeneric<TPage>);
    get blockType(): ApiBlockType;
    /**
     * Overall structural (not text) confidence score of the key/value pair detection
     *
     * Note this score describes the model's confidence in the validity of the key-value pair, not
     * the underlying OCR confidence of the text. (For that, see `.getOcrConfidence()` instead)
     *
     * Returns the average structure confidence over whichever of {key} and {value} are present.
     */
    get confidence(): number;
    get childBlockIds(): string[];
    get dict(): ApiKeyBlock | ApiKeyValueSetBlock;
    get id(): string;
    get key(): FieldKeyGeneric<TPage>;
    get parentForm(): FormGeneric<TPage>;
    get parentPage(): TPage;
    get text(): string;
    get value(): FieldValueGeneric<TPage> | null;
    /**
     * Aggregate OCR confidence score of the text in this field key and value (whichever are present)
     *
     * This score reflects the aggregated OCR confidence of all the text content detected in the
     * field key and/or value (whichever of the two are present). For the model's confidence on the
     * key/value relation itself, see `.confidence`.
     *
     * @param {AggregationMethod} aggMethod How to combine individual word OCR confidences together
     * @returns Aggregated confidence, or null if this field has no content/text
     */
    getOcrConfidence(aggMethod?: AggregationMethod): number | null;
    relatedBlockIdsByRelType(relType: ApiRelationshipType | ApiRelationshipType[]): string[];
    /**
     * The semantic `html()` representation of a form field uses an `<input>` element
     *
     * We render a text field, but `disable` it to prevent accidental edits when viewing reports
     */
    html(): string;
    str(): string;
}
/**
 * Generic class for a Form, as the parent Page is not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/Form`.
 */
export declare class FormGeneric<TPage extends IBlockManager> implements IRenderable {
    _fields: FieldGeneric<TPage>[];
    _fieldsMap: {
        [keyText: string]: FieldGeneric<TPage>;
    };
    _parentPage: TPage;
    constructor(keyBlocks: Array<ApiKeyBlock | ApiKeyValueSetBlock>, parentPage: TPage);
    get nFields(): number;
    get parentPage(): TPage;
    get text(): string;
    getFieldByKey(key: string): FieldGeneric<TPage> | null;
    /**
     * The semantic `html()` representation of a Form field collection uses a `<form>` element
     *
     * Within the `<form>`, we list out all the individual fields
     */
    html(): string;
    /**
     * Iterate through the Fields in the Form.
     * @param skipFieldsWithoutKey Set `true` to skip fields with no field.key (Included by default)
     * @example
     * for (const field of form.iterFields()) {
     *   console.log(field?.key.text);
     * }
     * @example
     * const fields = [...form.iterFields()];
     */
    iterFields(skipFieldsWithoutKey?: boolean): Iterable<FieldGeneric<TPage>>;
    /**
     * List the Fields in the Form.
     * @param skipFieldsWithoutKey Set `true` to skip fields with no field.key (Included by default)
     */
    listFields(skipFieldsWithoutKey?: boolean): FieldGeneric<TPage>[];
    /**
     * List the Fields in the Form with key text containing (case-insensitive) `key`
     * @param key The text to search for in field keys
     */
    searchFieldsByKey(key: string): FieldGeneric<TPage>[];
    str(): string;
}
/**
 * Generic base class for a composite of multiple Forms, as Page and TextractDocument are not defined here.
 *
 * If you're consuming this library, you probably just want to use `document.ts/FormsComposite`.
 *
 * While a Form is associated with a particular page, the FormsComposite class exposes a similar interface
 * for querying detected fields across all pages of the document at once. In general, results are analyzed
 * and presented in page order.
 */
export declare class FormsCompositeGeneric<TPage extends IBlockManager, TDocument extends IDocBlocks> implements IRenderable {
    _forms: FormGeneric<TPage>[];
    _parentDocument: TDocument;
    constructor(forms: FormGeneric<TPage>[], parentDocument: TDocument);
    get nFields(): number;
    get parentDocument(): TDocument;
    get text(): string;
    getFieldByKey(key: string): FieldGeneric<TPage> | null;
    /**
     * The semantic `html()` for a composite form uses a `<div>` of class "form-page"
     *
     * Within the container, we render the representation of each page's separate `<form>`.
     */
    html(): string;
    /**
     * Iterate through the Fields in all Forms.
     * @param skipFieldsWithoutKey Set `true` to skip fields with no field.key (Included by default)
     * @example
     * for (const field of form.iterFields()) {
     *   console.log(field?.key.text);
     * }
     * @example
     * const fields = [...form.iterFields()];
     */
    iterFields(skipFieldsWithoutKey?: boolean): Iterable<FieldGeneric<TPage>>;
    /**
     * List the Fields in all Forms.
     * @param skipFieldsWithoutKey Set `true` to skip fields with no field.key (Included by default)
     */
    listFields(skipFieldsWithoutKey?: boolean): FieldGeneric<TPage>[];
    /**
     * List the Fields in the Form with key text containing (case-insensitive) `key`
     * @param key The text to search for in field keys
     */
    searchFieldsByKey(key: string): FieldGeneric<TPage>[];
    str(): string;
}
/**
 * Interface for a (`Page`-like) object that exposes page-level form data
 */
export interface IWithForm<TPage extends IBlockManager> {
    /**
     * Parsed Forms (key-value pairs) data
     */
    form: FormGeneric<TPage>;
}
/**
 * Interface for a (`TextractDocument`-like) object that exposes document-level composite form data
 */
export interface IWithFormsComposite<TPage extends IBlockManager, TDocument extends IDocBlocks> {
    /**
     * Parsed Forms (key-value pairs) data
     */
    form: FormsCompositeGeneric<TPage, TDocument>;
}
export {};
